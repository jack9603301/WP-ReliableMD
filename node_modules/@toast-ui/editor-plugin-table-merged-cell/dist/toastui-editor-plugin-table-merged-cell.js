/*!
 * TOAST UI Editor : Table Merged Cell Plugin
 * @version 1.0.0 | Wed Mar 18 2020
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 21);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Generate an integer Array containing an arithmetic progression.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isUndefined = __webpack_require__(6);

/**
 * Generate an integer Array containing an arithmetic progression.
 * @param {number} start - start index
 * @param {number} stop - stop index
 * @param {number} step - next visit index = current index + step
 * @returns {Array}
 * @memberof module:array
 * @example
 * var range = require('tui-code-snippet/array/range'); // node, commonjs
 *
 * range(5); // [0, 1, 2, 3, 4]
 * range(1, 5); // [1,2,3,4]
 * range(2, 10, 2); // [2,4,6,8]
 * range(10, 2, -2); // [10,8,6,4]
 */
function range(start, stop, step) {
  var arr = [];
  var flag;

  if (isUndefined(stop)) {
    stop = start || 0;
    start = 0;
  }

  step = step || 1;
  flag = step < 0 ? -1 : 1;
  stop *= flag;

  for (; start * flag < stop; start += step) {
    arr.push(start);
  }

  return arr;
}

module.exports = range;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is existing or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isUndefined = __webpack_require__(6);
var isNull = __webpack_require__(19);

/**
 * Check whether the given variable is existing or not.
 * If the given variable is not null and not undefined, returns true.
 * @param {*} param - Target for checking
 * @returns {boolean} Is existy?
 * @memberof module:type
 * @example
 * var isExisty = require('tui-code-snippet/type/isExisty'); // node, commonjs
 *
 * isExisty(''); //true
 * isExisty(0); //true
 * isExisty([]); //true
 * isExisty({}); //true
 * isExisty(null); //false
 * isExisty(undefined); //false
*/
function isExisty(param) {
  return !isUndefined(param) && !isNull(param);
}

module.exports = isExisty;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Find parent element recursively
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var matches = __webpack_require__(12);

/**
 * Find parent element recursively
 * @param {HTMLElement} element - base element to start find
 * @param {string} selector - selector string for find
 * @returns {HTMLElement} - element finded or null
 * @memberof module:domUtil
 */
function closest(element, selector) {
  var parent = element.parentNode;

  if (matches(element, selector)) {
    return element;
  }

  while (parent && parent !== document) {
    if (matches(parent, selector)) {
      return parent;
    }

    parent = parent.parentNode;
  }

  return null;
}

module.exports = closest;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Transform the Array-like object to Array.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEachArray = __webpack_require__(9);

/**
 * Transform the Array-like object to Array.
 * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
 * @param {*} arrayLike Array-like object
 * @returns {Array} Array
 * @memberof module:collection
 * @example
 * var toArray = require('tui-code-snippet/collection/toArray'); // node, commonjs
 *
 * var arrayLike = {
 *     0: 'one',
 *     1: 'two',
 *     2: 'three',
 *     3: 'four',
 *     length: 4
 * };
 * var result = toArray(arrayLike);
 *
 * alert(result instanceof Array); // true
 * alert(result); // one,two,three,four
 */
function toArray(arrayLike) {
  var arr;
  try {
    arr = Array.prototype.slice.call(arrayLike);
  } catch (e) {
    arr = [];
    forEachArray(arrayLike, function(value) {
      arr.push(value);
    });
  }

  return arr;
}

module.exports = toArray;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Extend the target object from other objects.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * @module object
 */

/**
 * Extend the target object from other objects.
 * @param {object} target - Object that will be extended
 * @param {...object} objects - Objects as sources
 * @returns {object} Extended object
 * @memberof module:object
 */
function extend(target, objects) { // eslint-disable-line no-unused-vars
  var hasOwnProp = Object.prototype.hasOwnProperty;
  var source, prop, i, len;

  for (i = 1, len = arguments.length; i < len; i += 1) {
    source = arguments[i];
    for (prop in source) {
      if (hasOwnProp.call(source, prop)) {
        target[prop] = source[prop];
      }
    }
  }

  return target;
}

module.exports = extend;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isArray = __webpack_require__(10);
var forEachArray = __webpack_require__(9);
var forEachOwnProperties = __webpack_require__(18);

/**
 * @module collection
 */

/**
 * Execute the provided callback once for each property of object(or element of array) which actually exist.
 * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the property(or The value of the element)
 *  2) The name of the property(or The index of the element)
 *  3) The object being traversed
 * @param {Object} obj The object that will be traversed
 * @param {function} iteratee Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * var forEach = require('tui-code-snippet/collection/forEach'); // node, commonjs
 *
 * var sum = 0;
 *
 * forEach([1,2,3], function(value){
 *     sum += value;
 * });
 * alert(sum); // 6
 *
 * // In case of Array-like object
 * var array = Array.prototype.slice.call(arrayLike); // change to array
 * forEach(array, function(value){
 *     sum += value;
 * });
 */
function forEach(obj, iteratee, context) {
  if (isArray(obj)) {
    forEachArray(obj, iteratee, context);
  } else {
    forEachOwnProperties(obj, iteratee, context);
  }
}

module.exports = forEach;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is undefined or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is undefined or not.
 * If the given variable is undefined, returns true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is undefined?
 * @memberof module:type
 */
function isUndefined(obj) {
  return obj === undefined; // eslint-disable-line no-undefined
}

module.exports = isUndefined;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview This module detects the kind of well-known browser and version.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Browser module
 * @module browser
 */

/**
 * This object has an information that indicate the kind of browser.
 * The list below is a detectable browser list.
 *  - ie8 ~ ie11
 *  - chrome
 *  - firefox
 *  - safari
 *  - edge
 * @memberof module:browser
 * @example
 * var browser = require('tui-code-snippet/browser/browser'); // node, commonjs
 *
 * browser.chrome === true; // chrome
 * browser.firefox === true; // firefox
 * browser.safari === true; // safari
 * browser.msie === true; // IE
 * browser.edge === true; // edge
 * browser.others === true; // other browser
 * browser.version; // browser version
 */
var browser = {
  chrome: false,
  firefox: false,
  safari: false,
  msie: false,
  edge: false,
  others: false,
  version: 0
};

if (window && window.navigator) {
  detectBrowser();
}

/**
 * Detect the browser.
 * @private
 */
function detectBrowser() {
  var nav = window.navigator;
  var appName = nav.appName.replace(/\s/g, '_');
  var userAgent = nav.userAgent;

  var rIE = /MSIE\s([0-9]+[.0-9]*)/;
  var rIE11 = /Trident.*rv:11\./;
  var rEdge = /Edge\/(\d+)\./;
  var versionRegex = {
    firefox: /Firefox\/(\d+)\./,
    chrome: /Chrome\/(\d+)\./,
    safari: /Version\/([\d.]+).*Safari\/(\d+)/
  };

  var key, tmp;

  var detector = {
    Microsoft_Internet_Explorer: function() { // eslint-disable-line camelcase
      var detectedVersion = userAgent.match(rIE);

      if (detectedVersion) { // ie8 ~ ie10
        browser.msie = true;
        browser.version = parseFloat(detectedVersion[1]);
      } else { // no version information
        browser.others = true;
      }
    },
    Netscape: function() { // eslint-disable-line complexity
      var detected = false;

      if (rIE11.exec(userAgent)) {
        browser.msie = true;
        browser.version = 11;
        detected = true;
      } else if (rEdge.exec(userAgent)) {
        browser.edge = true;
        browser.version = userAgent.match(rEdge)[1];
        detected = true;
      } else {
        for (key in versionRegex) {
          if (versionRegex.hasOwnProperty(key)) {
            tmp = userAgent.match(versionRegex[key]);
            if (tmp && tmp.length > 1) { // eslint-disable-line max-depth
              browser[key] = detected = true;
              browser.version = parseFloat(tmp[1] || 0);
              break;
            }
          }
        }
      }
      if (!detected) {
        browser.others = true;
      }
    }
  };

  var fn = detector[appName];

  if (fn) {
    detector[appName]();
  }
}

module.exports = browser;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Add css class to element
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEach = __webpack_require__(5);
var inArray = __webpack_require__(11);
var getClass = __webpack_require__(15);
var setClassName = __webpack_require__(16);

/**
 * domUtil module
 * @module domUtil
 */

/**
 * Add css class to element
 * @param {(HTMLElement|SVGElement)} element - target element
 * @param {...string} cssClass - css classes to add
 * @memberof module:domUtil
 */
function addClass(element) {
  var cssClass = Array.prototype.slice.call(arguments, 1);
  var classList = element.classList;
  var newClass = [];
  var origin;

  if (classList) {
    forEach(cssClass, function(name) {
      element.classList.add(name);
    });

    return;
  }

  origin = getClass(element);

  if (origin) {
    cssClass = [].concat(origin.split(/\s+/), cssClass);
  }

  forEach(cssClass, function(cls) {
    if (inArray(cls, newClass) < 0) {
      newClass.push(cls);
    }
  });

  setClassName(element, newClass);
}

module.exports = addClass;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Execute the provided callback once for each element present
 * in the array(or Array-like object) in ascending order.
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the element
 *  2) The index of the element
 *  3) The array(or Array-like object) being traversed
 * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed
 * @param {function} iteratee Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * var forEachArray = require('tui-code-snippet/collection/forEachArray'); // node, commonjs
 *
 * var sum = 0;
 *
 * forEachArray([1,2,3], function(value){
 *     sum += value;
 * });
 * alert(sum); // 6
 */
function forEachArray(arr, iteratee, context) {
  var index = 0;
  var len = arr.length;

  context = context || null;

  for (; index < len; index += 1) {
    if (iteratee.call(context, arr[index], index, arr) === false) {
      break;
    }
  }
}

module.exports = forEachArray;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is an instance of Array or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is an instance of Array or not.
 * If the given variable is an instance of Array, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is array instance?
 * @memberof module:type
 */
function isArray(obj) {
  return obj instanceof Array;
}

module.exports = isArray;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable complexity */
/**
 * @fileoverview Returns the first index at which a given element can be found in the array.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isArray = __webpack_require__(10);

/**
 * @module array
 */

/**
 * Returns the first index at which a given element can be found in the array
 * from start index(default 0), or -1 if it is not present.
 * It compares searchElement to elements of the Array using strict equality
 * (the same method used by the ===, or triple-equals, operator).
 * @param {*} searchElement Element to locate in the array
 * @param {Array} array Array that will be traversed.
 * @param {number} startIndex Start index in array for searching (default 0)
 * @returns {number} the First index at which a given element, or -1 if it is not present
 * @memberof module:array
 * @example
 * var inArray = require('tui-code-snippet/array/inArray'); // node, commonjs
 *
 * var arr = ['one', 'two', 'three', 'four'];
 * var idx1 = inArray('one', arr, 3); // -1
 * var idx2 = inArray('one', arr); // 0
 */
function inArray(searchElement, array, startIndex) {
  var i;
  var length;
  startIndex = startIndex || 0;

  if (!isArray(array)) {
    return -1;
  }

  if (Array.prototype.indexOf) {
    return Array.prototype.indexOf.call(array, searchElement, startIndex);
  }

  length = array.length;
  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
    if (array[i] === searchElement) {
      return i;
    }
  }

  return -1;
}

module.exports = inArray;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Check element match selector
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var inArray = __webpack_require__(11);
var toArray = __webpack_require__(3);

var elProto = Element.prototype;
var matchSelector = elProto.matches ||
    elProto.webkitMatchesSelector ||
    elProto.mozMatchesSelector ||
    elProto.msMatchesSelector ||
    function(selector) {
      var doc = this.document || this.ownerDocument;

      return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;
    };

/**
 * Check element match selector
 * @param {HTMLElement} element - element to check
 * @param {string} selector - selector to check
 * @returns {boolean} is selector matched to element?
 * @memberof module:domUtil
 */
function matches(element, selector) {
  return matchSelector.call(element, selector);
}

module.exports = matches;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Fetch a property
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEach = __webpack_require__(5);

/**
 * fetching a property
 * @param {Array} arr target collection
 * @param {String|Number} property property name
 * @returns {Array}
 * @memberof module:collection
 * @example
 * var pluck = require('tui-code-snippe/collection/pluck'); // node, commonjs
 *
 * var objArr = [
 *     {'abc': 1, 'def': 2, 'ghi': 3},
 *     {'abc': 4, 'def': 5, 'ghi': 6},
 *     {'abc': 7, 'def': 8, 'ghi': 9}
 * ];
 * var arr2d = [
 *     [1, 2, 3],
 *     [4, 5, 6],
 *     [7, 8, 9]
 * ];
 * pluck(objArr, 'abc'); // [1, 4, 7]
 * pluck(arr2d, 2); // [3, 6, 9]
 */
function pluck(arr, property) {
  var resultArray = [];

  forEach(arr, function(item) {
    resultArray.push(item[property]);
  });

  return resultArray;
}

module.exports = pluck;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Setting element style
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isString = __webpack_require__(20);
var forEach = __webpack_require__(5);

/**
 * Setting element style
 * @param {(HTMLElement|SVGElement)} element - element to setting style
 * @param {(string|object)} key - style prop name or {prop: value} pair object
 * @param {string} [value] - style value
 * @memberof module:domUtil
 */
function css(element, key, value) {
  var style = element.style;

  if (isString(key)) {
    style[key] = value;

    return;
  }

  forEach(key, function(v, k) {
    style[k] = v;
  });
}

module.exports = css;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Get HTML element's design classes.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isUndefined = __webpack_require__(6);

/**
 * Get HTML element's design classes.
 * @param {(HTMLElement|SVGElement)} element target element
 * @returns {string} element css class name
 * @memberof module:domUtil
 */
function getClass(element) {
  if (!element || !element.className) {
    return '';
  }

  if (isUndefined(element.className.baseVal)) {
    return element.className;
  }

  return element.className.baseVal;
}

module.exports = getClass;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Set className value
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isArray = __webpack_require__(10);
var isUndefined = __webpack_require__(6);

/**
 * Set className value
 * @param {(HTMLElement|SVGElement)} element - target element
 * @param {(string|string[])} cssClass - class names
 * @private
 */
function setClassName(element, cssClass) {
  cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;

  cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

  if (isUndefined(element.className.baseVal)) {
    element.className = cssClass;

    return;
  }

  element.className.baseVal = cssClass;
}

module.exports = setClassName;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Remove css class from element
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEachArray = __webpack_require__(9);
var inArray = __webpack_require__(11);
var getClass = __webpack_require__(15);
var setClassName = __webpack_require__(16);

/**
 * Remove css class from element
 * @param {(HTMLElement|SVGElement)} element - target element
 * @param {...string} cssClass - css classes to remove
 * @memberof module:domUtil
 */
function removeClass(element) {
  var cssClass = Array.prototype.slice.call(arguments, 1);
  var classList = element.classList;
  var origin, newClass;

  if (classList) {
    forEachArray(cssClass, function(name) {
      classList.remove(name);
    });

    return;
  }

  origin = getClass(element).split(/\s+/);
  newClass = [];
  forEachArray(origin, function(name) {
    if (inArray(name, cssClass) < 0) {
      newClass.push(name);
    }
  });

  setClassName(element, newClass);
}

module.exports = removeClass;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Execute the provided callback once for each property of object which actually exist.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Execute the provided callback once for each property of object which actually exist.
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the property
 *  2) The name of the property
 *  3) The object being traversed
 * @param {Object} obj The object that will be traversed
 * @param {function} iteratee  Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * var forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); // node, commonjs
 *
 * var sum = 0;
 *
 * forEachOwnProperties({a:1,b:2,c:3}, function(value){
 *     sum += value;
 * });
 * alert(sum); // 6
 */
function forEachOwnProperties(obj, iteratee, context) {
  var key;

  context = context || null;

  for (key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (iteratee.call(context, obj[key], key, obj) === false) {
        break;
      }
    }
  }
}

module.exports = forEachOwnProperties;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is null or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is null or not.
 * If the given variable(arguments[0]) is null, returns true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is null?
 * @memberof module:type
 */
function isNull(obj) {
  return obj === null;
}

module.exports = isNull;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is a string or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is a string or not.
 * If the given variable is a string, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is string?
 * @memberof module:type
 */
function isString(obj) {
  return typeof obj === 'string' || obj instanceof String;
}

module.exports = isString;


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ tableMergedCellPlugin; });

// EXTERNAL MODULE: ./node_modules/tui-code-snippet/collection/toArray.js
var toArray = __webpack_require__(3);
var toArray_default = /*#__PURE__*/__webpack_require__.n(toArray);

// CONCATENATED MODULE: ./src/js/langs.js
/**
 * @fileoverview i18n for table-merged-cell plugin
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */
function addLangs(editor) {
  var Editor = Object.getPrototypeOf(editor).constructor;

  if (Editor) {
    Editor.setLanguage(['ko', 'ko-KR'], {
      'Merge cells': '셀 병합',
      'Unmerge cells': '셀 병합해제',
      'Cannot change part of merged cell': '병합 된 셀의 일부를 변경할 수 없습니다.',
      'Cannot paste row merged cells into the table header': '테이블 헤더에는 행 병합된 셀을 붙여넣을 수 없습니다.'
    });
    Editor.setLanguage(['en', 'en-US'], {
      'Merge cells': 'Merge cells',
      'Unmerge cells': 'Unmerge cells',
      'Cannot change part of merged cell': 'Cannot change part of merged cell.',
      'Cannot paste row merged cells into the table header': 'Cannot paste row merged cells into the table header.'
    });
    Editor.setLanguage(['es', 'es-ES'], {
      'Merge cells': 'Combinar celdas',
      'Unmerge cells': 'Separar celdas',
      'Cannot change part of merged cell': 'No se puede cambiar parte de una celda combinada.',
      'Cannot paste row merged cells into the table header': 'No se pueden pegar celdas combinadas en el encabezado de tabla.'
    });
    Editor.setLanguage(['ja', 'ja-JP'], {
      'Merge cells': 'セルの結合',
      'Unmerge cells': 'セルの結合を解除',
      'Cannot change part of merged cell': '結合されたセルの一部を変更することはできません。',
      'Cannot paste row merged cells into the table header': '行にマージされたセルをヘッダーに貼り付けることはできません。'
    });
    Editor.setLanguage(['nl', 'nl-NL'], {
      'Merge cells': 'Cellen samenvoegen',
      'Unmerge cells': 'Samengevoegde cellen ongedaan maken',
      'Cannot change part of merged cell': 'Kan geen deel uit van een samengevoegde cel veranderen.',
      'Cannot paste row merged cells into the table header': 'Kan geen rij met samengevoegde cellen in de koptekst plakken.'
    });
    Editor.setLanguage('zh-CN', {
      'Merge cells': '合并单元格',
      'Unmerge cells': '取消合并单元格',
      'Cannot change part of merged cell': '无法更改合并单元格的一部分。',
      'Cannot paste row merged cells into the table header': '无法将行合并单元格粘贴到标题中。'
    });
    Editor.setLanguage(['de', 'de-DE'], {
      'Merge cells': 'Zellen zusammenführen',
      'Unmerge cells': 'Zusammenführen rückgängig machen',
      'Cannot change part of merged cell': 'Der Teil der verbundenen Zelle kann nicht geändert werden.',
      'Cannot paste row merged cells into the table header': 'Die Zeile der verbundenen Zellen kann nicht in die Kopfzeile eingefügt werden.'
    });
    Editor.setLanguage(['ru', 'ru-RU'], {
      'Merge cells': 'Объединить ячейки',
      'Unmerge cells': 'Разъединить ячейки',
      'Cannot change part of merged cell': 'Вы не можете изменять часть комбинированной ячейки.',
      'Cannot paste row merged cells into the table header': 'Вы не можете вставлять объединенные ячейки в заголовок таблицы.'
    });
    Editor.setLanguage(['fr', 'fr-FR'], {
      'Merge cells': 'Fusionner les cellules',
      'Unmerge cells': 'Séparer les cellules',
      'Cannot change part of merged cell': 'Impossible de modifier une partie de la cellule fusionnée.',
      'Cannot paste row merged cells into the table header': "Impossible de coller les cellules fusionnées dans l'en-tête du tableau."
    });
    Editor.setLanguage(['uk', 'uk-UA'], {
      'Merge cells': "Об'єднати комірки",
      'Unmerge cells': "Роз'єднати комірки",
      'Cannot change part of merged cell': 'Ви не можете змінювати частину комбінованої комірки.',
      'Cannot paste row merged cells into the table header': "Ви не можете вставляти об'єднані комірки в заголовок таблиці."
    });
    Editor.setLanguage(['tr', 'tr-TR'], {
      'Merge cells': 'Hücreleri birleştir',
      'Unmerge cells': 'Hücreleri ayır',
      'Cannot change part of merged cell': 'Birleştirilmiş hücrelerin bir kısmı değiştirelemez.',
      'Cannot paste row merged cells into the table header': 'Satırda birleştirilmiş hücreler sütun başlığına yapıştırılamaz'
    });
    Editor.setLanguage(['fi', 'fi-FI'], {
      'Merge cells': 'Yhdistä solut',
      'Unmerge cells': 'Jaa solut',
      'Cannot change part of merged cell': 'Yhdistettyjen solujen osaa ei voi muuttaa',
      'Cannot paste row merged cells into the table header': 'Soluja ei voi yhdistää taulukon otsikkoriviin'
    });
    Editor.setLanguage(['cs', 'cs-CZ'], {
      'Merge cells': 'Spojit buňky',
      'Unmerge cells': 'Rozpojit buňky',
      'Cannot change part of merged cell': 'Nelze měnit část spojené buňky',
      'Cannot paste row merged cells into the table header': 'Nelze vkládat spojené buňky do záhlaví tabulky'
    });
    Editor.setLanguage('ar', {
      'Merge cells': 'دمج الوحدات',
      'Unmerge cells': 'إلغاء دمج الوحدات',
      'Cannot change part of merged cell': 'لا يمكن تغيير جزء من الخلية المدموجة',
      'Cannot paste row merged cells into the table header': 'لا يمكن لصق الخلايا المدموجة من صف واحد في رأس الجدول'
    });
    Editor.setLanguage(['pl', 'pl-PL'], {
      'Merge cells': 'Scal komórki',
      'Unmerge cells': 'Rozłącz komórki',
      'Cannot change part of merged cell': 'Nie można zmienić części scalonej komórki.',
      'Cannot paste row merged cells into the table header': 'Nie można wkleić komórek o scalonym rzędzie w nagłówek tabeli.'
    });
    Editor.setLanguage('zh-TW', {
      'Merge cells': '合併儲存格',
      'Unmerge cells': '取消合併儲存格',
      'Cannot change part of merged cell': '無法變更儲存格的一部分。',
      'Cannot paste row merged cells into the table header': '無法將合併的儲存格貼上至表格標題中。'
    });
    Editor.setLanguage(['gl', 'gl-ES'], {
      'Merge cells': 'Combinar celas',
      'Unmerge cells': 'Separar celas',
      'Cannot change part of merged cell': 'Non se pode cambiar parte dunha cela combinada',
      'Cannot paste row merged cells into the table header': 'Non se poden pegar celas no encabezado da táboa'
    });
    Editor.setLanguage(['sv', 'sv-SE'], {
      'Merge cells': 'Sammanfoga celler',
      'Unmerge cells': 'Dela celler',
      'Cannot change part of merged cell': 'Ej möjligt att ändra en del av en sammanfogad cell',
      'Cannot paste row merged cells into the table header': 'Ej möjligt att klistra in rad-sammanfogade celler i tabellens huvud'
    });
    Editor.setLanguage(['it', 'it-IT'], {
      'Merge cells': 'Unisci celle',
      'Unmerge cells': 'Separa celle',
      'Cannot change part of merged cell': 'Non è possibile modificare parte di una cella unita',
      'Cannot paste row merged cells into the table header': "Non è possibile incollare celle unite per riga nell'intestazione della tabella"
    });
    Editor.setLanguage(['nb', 'nb-NO'], {
      'Merge cells': 'Slå sammen celler',
      'Unmerge cells': 'Separer celler',
      'Cannot change part of merged cell': 'Kan ikke endre deler av sammenslåtte celler',
      'Cannot paste row merged cells into the table header': 'Kan ikke lime inn rad med sammenslåtte celler'
    });
  }
}
// EXTERNAL MODULE: ./node_modules/tui-code-snippet/collection/forEach.js
var forEach = __webpack_require__(5);
var forEach_default = /*#__PURE__*/__webpack_require__.n(forEach);

// EXTERNAL MODULE: ./node_modules/tui-code-snippet/type/isUndefined.js
var isUndefined = __webpack_require__(6);
var isUndefined_default = /*#__PURE__*/__webpack_require__.n(isUndefined);

// EXTERNAL MODULE: ./node_modules/tui-code-snippet/type/isExisty.js
var isExisty = __webpack_require__(1);
var isExisty_default = /*#__PURE__*/__webpack_require__.n(isExisty);

// EXTERNAL MODULE: ./node_modules/tui-code-snippet/object/extend.js
var extend = __webpack_require__(4);
var extend_default = /*#__PURE__*/__webpack_require__.n(extend);

// EXTERNAL MODULE: ./node_modules/tui-code-snippet/array/range.js
var array_range = __webpack_require__(0);
var range_default = /*#__PURE__*/__webpack_require__.n(array_range);

// EXTERNAL MODULE: ./node_modules/tui-code-snippet/browser/browser.js
var browser = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/tui-code-snippet/domUtil/closest.js
var closest = __webpack_require__(2);
var closest_default = /*#__PURE__*/__webpack_require__.n(closest);

// CONCATENATED MODULE: ./src/js/tableDataHandler.js
/**
 * @fileoverview Implements tableDataHandler
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */







/**
 * Parse cell like td or th.
 * @param {HTMLElement} cell - cell element like td or th
 * @param {number} rowIndex - row index
 * @param {number} colIndex - column index
 * @returns {{
 *   nodeName: string,
 *   colspan: number,
 *   rowspan: number,
 *   content: string,
 *   align: ?string
 * }}
 * @private
 */

/* eslint-disable complexity */

function _parseCell(cell, rowIndex, colIndex) {
  var colspan = cell.getAttribute('colspan');
  var rowspan = cell.getAttribute('rowspan');
  var nodeName = cell.nodeName;

  if (nodeName !== 'TH' && nodeName !== 'TD') {
    return null;
  }

  var cellData = {
    nodeName: cell.nodeName,
    colspan: colspan ? parseInt(colspan, 10) : 1,
    rowspan: rowspan ? parseInt(rowspan, 10) : 1,
    content: cell.innerHTML,
    elementIndex: {
      rowIndex: rowIndex,
      colIndex: colIndex
    }
  };

  if (cell.nodeName === 'TH' && cell.align) {
    cellData.align = cell.align;
  }

  return cellData;
}
/**
 * Add merged cell.
 * @param {object} base - base table data
 * @param {object} cellData - cell data
 * @param {number} startRowIndex - start row index
 * @param {number} startCellIndex - start cell index
 * @private
 */


function _addMergedCell(base, cellData, startRowIndex, startCellIndex) {
  var colspan = cellData.colspan,
      rowspan = cellData.rowspan,
      nodeName = cellData.nodeName;
  var colMerged = colspan > 1;
  var rowMerged = rowspan > 1;

  if (!colMerged && !rowMerged) {
    return;
  }

  var limitRowIndex = startRowIndex + rowspan;
  var limitCellIndex = startCellIndex + colspan;
  range_default()(startRowIndex, limitRowIndex).forEach(function (rowIndex) {
    base[rowIndex] = base[rowIndex] || [];
    range_default()(startCellIndex, limitCellIndex).forEach(function (cellIndex) {
      var mergedData = {
        nodeName: nodeName
      };

      if (rowIndex === startRowIndex && cellIndex === startCellIndex) {
        return;
      }

      if (colMerged) {
        mergedData.colMergeWith = startCellIndex;
      }

      if (rowMerged) {
        mergedData.rowMergeWith = startRowIndex;
      }

      base[rowIndex][cellIndex] = mergedData;
    });
  });
}
/**
 * Create table data from table Element.
 * @param {HTMLElement} table - table element
 * @returns {Array.<Array.<object>>}
 * @ignore
 */


function createTableData(table) {
  var tableData = [];
  var trs = toArray_default()(table.querySelectorAll('tr'));
  trs.forEach(function (tr, rowIndex) {
    var stackedColCount = 0;
    tableData[rowIndex] = tableData[rowIndex] || [];
    toArray_default()(tr.children).forEach(function (cell, colIndex) {
      var cellData = _parseCell(cell, rowIndex, colIndex);

      if (!cellData) {
        return;
      }

      var dataColIndex = colIndex + stackedColCount;

      while (tableData[rowIndex][dataColIndex]) {
        dataColIndex += 1;
        stackedColCount += 1;
      }

      tableData[rowIndex][dataColIndex] = cellData;

      _addMergedCell(tableData, cellData, rowIndex, dataColIndex);
    });
  });

  if (table.className) {
    tableData.className = table.className;
  }

  return tableData;
}
/**
 * Create cell index data of table data.
 * @param {Array.<Array.<object>>} tableData - table data
 * @returns {Array.<Array.<object>>}
 * @ignore
 */

function createCellIndexData(tableData) {
  var mappingData = [];
  tableData.forEach(function (row, rowIndex) {
    var mappingRow = [];
    row.forEach(function (cell, colIndex) {
      if (isUndefined_default()(cell.colMergeWith) && isUndefined_default()(cell.rowMergeWith)) {
        mappingRow.push({
          rowIndex: rowIndex,
          colIndex: colIndex
        });
      }
    });
    mappingData.push(mappingRow);
  });
  return mappingData;
}
/**
 * Get header aligns.
 * @param {Array.<Array.<object>>} tableData - table data
 * @returns {Array.<?string>}
 * @private
 */

function _getHeaderAligns(tableData) {
  var headRowData = tableData[0];
  return headRowData.map(function (cellData) {
    var align;

    if (isExisty_default()(cellData.colMergeWith)) {
      align = headRowData[cellData.colMergeWith].align;
    } else {
      align = cellData.align;
    }

    return align;
  });
}
/**
 * Create render data.
 * @param {Array.<object>} tableData - table data
 * @param {Array.<object>} cellIndexData - cell index data
 * @returns {Array.<Array.<object>>}
 * @ignore
 */


function createRenderData(tableData, cellIndexData) {
  var headerAligns = _getHeaderAligns(tableData);

  var renderData = cellIndexData.map(function (row) {
    return row.map(function (_ref) {
      var rowIndex = _ref.rowIndex,
          colIndex = _ref.colIndex;
      return extend_default()({
        align: headerAligns[colIndex]
      }, tableData[rowIndex][colIndex]);
    });
  });

  if (tableData.className) {
    renderData.className = tableData.className;
  }

  return renderData;
}

var BASIC_CELL_CONTENT = browser["msie"] ? '' : '<br>';
/**
 * Create basic cell data.
 * @param {number} rowIndex - row index
 * @param {number} colIndex - column index
 * @param {string} nodeName - node name
 * @returns {{
 *   nodeName: string,
 *   colspan: number,
 *   rowspan: number,
 *   content: string
 * }}
 * @ignore
 */

function createBasicCell(rowIndex, colIndex, nodeName) {
  return {
    nodeName: nodeName || 'TD',
    colspan: 1,
    rowspan: 1,
    content: BASIC_CELL_CONTENT,
    elementIndex: {
      rowIndex: rowIndex,
      colIndex: colIndex
    }
  };
}

function getPreviousSiblingsCount(element) {
  var previousSiblings = [];
  var current = element.previousSibling;

  while (current) {
    if (current.nodeType === 1) {
      previousSiblings.push(current);
    }

    current = current.previousSibling;
  }

  return previousSiblings.length;
}
/**
 * Find element row index.
 * @param {HTMLElement} cell - cell element like td or th
 * @returns {number}
 * @ignore
 */


function findElementRowIndex(cell) {
  cell = cell.nodeType !== 1 ? cell.parentNode : cell;
  var tr = closest_default()(cell, 'tr');
  var rowIndex = getPreviousSiblingsCount(tr);

  if (tr.parentNode.nodeName === 'TBODY') {
    rowIndex += 1;
  }

  return rowIndex;
}
/**
 * Find element col index.
 * @param {HTMLElement} cell - cell element like td or th
 * @returns {number}
 * @ignore
 */


function findElementColIndex(cell) {
  cell = cell.nodeType !== 1 ? cell.parentNode : cell;
  var td = closest_default()(cell, 'td, th');
  var columnsCount = getPreviousSiblingsCount(td);
  return columnsCount;
}
/**
 * Find indexes of base table data from mappin data.
 * @param {Array.<Array.<object>>} cellIndexData - cell index data
 * @param {HTMLElement} cell - cell element like td or th
 * @returns {{rowIndex: number, cellIndex: number}}
 * @ignore
 */


function findCellIndex(cellIndexData, cell) {
  var elementRowIndex = findElementRowIndex(cell);
  var elementColIndex = findElementColIndex(cell);
  return cellIndexData[elementRowIndex][elementColIndex];
}
/**
 * Find last index of col merged cells.
 * @param {Array.<Array.<object>>} tableData - tableData data
 * @param {number} rowIndex - row index of base data
 * @param {number} colIndex - column index of tabld data
 * @returns {number}
 * @ignore
 */


function findRowMergedLastIndex(tableData, rowIndex, colIndex) {
  var cellData = tableData[rowIndex][colIndex];
  var foundRowIndex = rowIndex;

  if (cellData.rowspan > 1) {
    foundRowIndex += cellData.rowspan - 1;
  }

  return foundRowIndex;
}
/**
 * Find last index of col merged cells.
 * @param {Array.<Array.<object>>} tableData - tableData data
 * @param {number} rowIndex - row index of base data
 * @param {number} colIndex - column index of tabld data
 * @returns {number}
 * @ignore
 */


function findColMergedLastIndex(tableData, rowIndex, colIndex) {
  var cellData = tableData[rowIndex][colIndex];
  var foundColIndex = colIndex;

  if (cellData.colspan > 1) {
    foundColIndex += cellData.colspan - 1;
  }

  return foundColIndex;
}
/**
 * Find cell element index.
 * @param {Array.<Array.<object>>} tableData - tableData data
 * @param {number} rowIndex - row index of base data
 * @param {number} colIndex - col index of base data
 * @returns {{rowIndex: number, colIndex: number}}
 * @ignore
 */


function findElementIndex(tableData, rowIndex, colIndex) {
  var cellData = tableData[rowIndex][colIndex];
  rowIndex = isExisty_default()(cellData.rowMergeWith) ? cellData.rowMergeWith : rowIndex;
  colIndex = isExisty_default()(cellData.colMergeWith) ? cellData.colMergeWith : colIndex;
  return tableData[rowIndex][colIndex].elementIndex;
}
/**
 * Stuff cells into incomplete row.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {number} limitIndex - limit index
 * @ignore
 */


function stuffCellsIntoIncompleteRow(tableData, limitIndex) {
  tableData.forEach(function (rowData, rowIndex) {
    var startIndex = rowData.length;

    if (startIndex) {
      var nodeName = rowData[0].nodeName;
      range_default()(startIndex, limitIndex).forEach(function (colIndex) {
        rowData.push(createBasicCell(rowIndex, colIndex, nodeName));
      });
    }
  });
}
/**
 * Add tbody or thead of table data if need.
 * @param {Array.<Array.<object>>} tableData - table data
 * @returns {boolean}
 * @ignore
 */


function addTbodyOrTheadIfNeed(tableData) {
  var header = tableData[0];
  var cellCount = header.length;
  var added = true;

  if (!cellCount && tableData[1]) {
    range_default()(0, tableData[1].length).forEach(function (colIndex) {
      header.push(createBasicCell(0, colIndex, 'TH'));
    });
  } else if (tableData[0][0].nodeName !== 'TH') {
    var _ref2;

    var newHeader = range_default()(0, cellCount).map(function (colIndex) {
      return createBasicCell(0, colIndex, 'TH');
    });

    (_ref2 = []).concat.apply(_ref2, tableData).forEach(function (cellData) {
      if (cellData.elementIndex) {
        cellData.elementIndex.rowIndex += 1;
      }
    });

    tableData.unshift(newHeader);
  } else if (tableData.length === 1) {
    var newRow = range_default()(0, cellCount).map(function (colIndex) {
      return createBasicCell(1, colIndex, 'TD');
    });
    tableData.push(newRow);
  } else {
    added = false;
  }

  return added;
}

/* harmony default export */ var tableDataHandler = ({
  createTableData: createTableData,
  createCellIndexData: createCellIndexData,
  createRenderData: createRenderData,
  findElementRowIndex: findElementRowIndex,
  findElementColIndex: findElementColIndex,
  findCellIndex: findCellIndex,
  createBasicCell: createBasicCell,
  findRowMergedLastIndex: findRowMergedLastIndex,
  findColMergedLastIndex: findColMergedLastIndex,
  findElementIndex: findElementIndex,
  stuffCellsIntoIncompleteRow: stuffCellsIntoIncompleteRow,
  addTbodyOrTheadIfNeed: addTbodyOrTheadIfNeed
});
// CONCATENATED MODULE: ./src/js/tableRenderer.js
/**
 * @fileoverview Implements tableRenderer
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

/**
 * Create cell html.
 * @param {object} cell - cell data of table base data
 * @returns {string}
 * @private
 */

function _createCellHtml(cell) {
  var attrs = cell.colspan > 1 ? " colspan=\"" + cell.colspan + "\"" : '';
  attrs += cell.rowspan > 1 ? " rowspan=\"" + cell.rowspan + "\"" : '';
  attrs += cell.align ? " align=\"" + cell.align + "\"" : '';
  return "<" + cell.nodeName + attrs + ">" + cell.content + "</" + cell.nodeName + ">";
}
/**
 * Create html for thead or tbody.
 * @param {Array.<Array.<object>>} trs - tr list
 * @param {string} wrapperNodeName - wrapper node name like THEAD, TBODY
 * @returns {string}
 * @private
 */


function _createTheadOrTbodyHtml(trs, wrapperNodeName) {
  var html = '';

  if (trs.length) {
    html = trs.map(function (tr) {
      var tdHtml = tr.map(_createCellHtml).join('');
      return "<tr>" + tdHtml + "</tr>";
    }).join('');
    html = "<" + wrapperNodeName + ">" + html + "</" + wrapperNodeName + ">";
  }

  return html;
}
/**
 * Create table html.
 * @param {Array.<Array.<object>>} renderData - table data for render
 * @returns {string}
 * @private
 */


function createTableHtml(renderData) {
  var thead = renderData[0] ? [renderData[0]] : [];
  var tbody = renderData.slice(1);

  var theadHtml = _createTheadOrTbodyHtml(thead, 'THEAD');

  var tbodyHtml = _createTheadOrTbodyHtml(tbody, 'TBODY');

  var className = renderData.className ? " class=\"" + renderData.className + "\"" : '';
  return "<table" + className + ">" + (theadHtml + tbodyHtml) + "</table>";
}
/**
 * Replace table.
 * @param {HTMLElement} table - table element
 * @param {Array.<Array.<object>>} tableData - table data
 * @returns {HTMLElement}
 * @ignore
 */


function replaceTable(table, tableData) {
  var cellIndexData = tableDataHandler.createCellIndexData(tableData);
  var renderData = tableDataHandler.createRenderData(tableData, cellIndexData);
  var tempDiv = document.createElement('div');
  tempDiv.innerHTML = createTableHtml(renderData);
  table.innerHTML = tempDiv.innerHTML;
  return table;
}
/**
 * Focus to cell.
 * @param {squireext} sq - squire instance
 * @param {range} range - range object
 * @param {HTMLElement} targetCell - cell element for focus
 * @ignore
 */


function focusToCell(sq, range, targetCell) {
  range.selectNodeContents(targetCell);
  range.collapse(true);
  sq.setSelection(range);
}

/* harmony default export */ var tableRenderer = ({
  createTableHtml: createTableHtml,
  replaceTable: replaceTable,
  focusToCell: focusToCell
});
// CONCATENATED MODULE: ./src/js/mergedTableCreator.js
/**
 * @fileoverview Implements mergedTableCreator.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Extract properties for merge.
 * @param {string} value - value
 * @param {string} type - merge type like colspan, rowspan
 * @param {string} oppossitType - oppossit merge type
 *                                if merge type is colspan, opossit merge type is rowspan
 * @returns {Array.<number|string>} - returns merge count and value
 * @private
 */

function _extractPropertiesForMerge(value, type, oppossitType) {
  var regex = new RegExp("^((?:" + oppossitType + "=[0-9]+:)?)" + type + "=([0-9]+):(.*)");
  var regexResult = regex.exec(value);
  var mergeCount = 1;

  if (regexResult) {
    mergeCount = parseInt(regexResult[2], 10);
    value = regexResult[1] + regexResult[3];
  }

  return [mergeCount, value];
}
/**
 * Parse table cell element like td, th.
 * @param {HTMLElement} cell - table cell element like td, th
 * @returns {{
 *   nodeName: string,
 *   colspan: number,
 *   rowspan: number,
 *   content: string,
 *   align: string
 * }}
 * @private
 */

function _parseTableCell(cell) {
  var nodeName = cell.nodeName;
  var align = cell.align || '';
  var content = cell.innerHTML.trim();
  var colspan = null;
  var rowspan = null;

  var _extractPropertiesFor = _extractPropertiesForMerge(content, '@cols', '@rows');

  colspan = _extractPropertiesFor[0];
  content = _extractPropertiesFor[1];

  var _extractPropertiesFor2 = _extractPropertiesForMerge(content, '@rows', '@cols');

  rowspan = _extractPropertiesFor2[0];
  content = _extractPropertiesFor2[1];
  return {
    nodeName: nodeName,
    colspan: colspan,
    rowspan: rowspan,
    content: content,
    align: align
  };
}
/**
 * Create table object from table.
 * @param {HTMLElement} table - table element
 * @returns {Array.<Array.<object>>}
 * @private
 */

function _createTableObjectFromTable(table) {
  var trs = toArray_default()(table.querySelectorAll('tr'));
  return trs.map(function (tr) {
    var cells = toArray_default()(tr.querySelectorAll('td, th'));
    return cells.map(_parseTableCell);
  });
}
/**
 * Find index by onFind function.
 * @param {Array} arr - target array
 * @param {function} onFind - find function
 * @returns {number}
 * @private
 */

function _findIndex(arr, onFind) {
  var foundIndex = -1;
  forEach_default()(arr, function (item, index) {
    var nextFind = true;

    if (onFind(item, index)) {
      foundIndex = index;
      nextFind = false;
    }

    return nextFind;
  });
  return foundIndex;
}
/**
 * Separate the trs according to the type of parent, such as thead and tbody.
 * @param {Array.<Array.<object>>} trs - tr list
 * @returns {Array.<Array.<Array.<object>>>} - returns thead and tbody
 * @private
 */


function _divideTrs(trs) {
  var tbodyStartIndex = _findIndex(trs, function (tr) {
    return tr[0].nodeName === 'TD';
  });

  return [trs.slice(0, tbodyStartIndex), trs.slice(tbodyStartIndex)];
}
/**
 * Merge by colspan.
 * @param {Array.<Array.<object>>} trs - tr list
 * @private
 */

function _mergeByColspan(trs) {
  trs.forEach(function (tr) {
    var tdCount = tr.length;
    var removalCount = 0;
    tr.forEach(function (td) {
      removalCount += td.colspan - 1;
    });
    tr.splice(tdCount - removalCount);
  });
}
/**
 * Get removal td counts by rowspan.
 * @param {Array.<Array.<object>>} trs - tr list
 * @returns {number}
 * @private
 */

function _getRemovalTdCountsByRowspan(trs) {
  var trIndexes = trs.map(function (tr, index) {
    return index;
  });
  var removalCounts = trIndexes.map(function () {
    return 0;
  });
  trs.forEach(function (tr, trIndex) {
    var rowspanTds = tr.filter(function (td) {
      return td.rowspan > 1;
    });
    var startTrIndexForRemoval = trIndex + 1;
    rowspanTds.forEach(function (td) {
      var removeCount = td.colspan;
      var endTrIndexForRemoval = startTrIndexForRemoval + (td.rowspan - 1);
      trIndexes.slice(startTrIndexForRemoval, endTrIndexForRemoval).forEach(function (removeIndex) {
        removalCounts[removeIndex] += removeCount;
      });
    });
  });
  return removalCounts;
}
/**
 * Merge by rowspan.
 * @param {Array.<Array.<object>>} trs - tr list
 * @private
 */

function _mergeByRowspan(trs) {
  var removalCounts = _getRemovalTdCountsByRowspan(trs);

  trs.forEach(function (tr, trIndex) {
    tr.splice(tr.length - removalCounts[trIndex]);
  });
}
/**
 * Create merged table by @cols, @rows value in td innerHTML.
 * @param {HTMLElement} tableElement - unmerged table
 * @returns {HTMLElement}
 */

function createMergedTable(tableElement) {
  var table = _createTableObjectFromTable(tableElement);

  var _divideTrs2 = _divideTrs(table),
      thead = _divideTrs2[0],
      tbody = _divideTrs2[1];

  _mergeByColspan(thead);

  _mergeByColspan(tbody);

  _mergeByRowspan(tbody);

  var tempDiv = document.createElement('div');
  tempDiv.innerHTML = tableRenderer.createTableHtml(table);
  return tempDiv.firstChild;
}
// CONCATENATED MODULE: ./src/js/tableUnmergePreparer.js
/**
 * @fileoverview Implements tableUnmergePreparer.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

/**
 * Prepend merge syntax to content.
 * @param {HTMLElement} cell - td or th
 * @private
 */

function _prependMergeSyntaxToContent(cell) {
  var colspan = cell.getAttribute('colspan') || '';
  var rowspan = cell.getAttribute('rowspan') || '';
  var content = cell.innerHTML;

  if (colspan) {
    content = "@cols=" + colspan + ":" + content;
  }

  if (rowspan) {
    content = "@rows=" + rowspan + ":" + content;
  }

  if (content) {
    cell.innerHTML = content;
  }
}
/**
 * Prepare table unmerge.
 * @param {HTMLElement} tableElement - table element
 * @returns {HTMLElement}
 */

function prepareTableUnmerge(tableElement) {
  var cells = tableElement.querySelectorAll('td, th');
  toArray_default()(cells).forEach(_prependMergeSyntaxToContent);
  return tableElement;
}
// CONCATENATED MODULE: ./src/js/toMarkRenderer.js
/**
 * @fileoverview Implements toMarkRendererCreator.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */


var RX_COLS = /@cols=[0-9]+:/g;
/**
 * Create repeat string.
 * @param {string} str - target string
 * @param {number} count - count
 * @returns {string}
 * @private
 */

function _createRepeatString(str, count) {
  return range_default()(0, count).map(function () {
    return str;
  }).join('');
}
/**
 * Make table head align text.
 * Copy from https://github.com/nhn/to-mark/blob/develop/src/renderer.gfm.js
 * @param {HTMLElement} thElement - Table head cell element
 * @returns {string}
 * @private
 */


function _makeTableHeadAlignText(thElement) {
  var align = thElement.align;
  var textContent = (thElement.textContent || thElement.innerText).replace(RX_COLS, '');
  var textLength = textContent.length;
  var leftAlignValue = '';
  var rightAlignValue = '';

  if (align) {
    if (align === 'left') {
      leftAlignValue = ':';
      textLength -= 1;
    } else if (align === 'right') {
      rightAlignValue = ':';
      textLength -= 1;
    } else if (align === 'center') {
      rightAlignValue = ':';
      leftAlignValue = ':';
      textLength -= 2;
    }
  }

  textLength = Math.max(textLength, 3);
  return leftAlignValue + _createRepeatString('-', textLength) + rightAlignValue;
}
/**
 * Get additional th element count.
 * @param {Array.<HTMLElement>} ths - th element list
 * @private
 * @returns {Number}
 */


function _getAdditionalThCount(ths) {
  var additionalThCount = 0;
  ths.filter(function (th) {
    return th.getAttribute('colspan');
  }).forEach(function (th) {
    additionalThCount += parseInt(th.getAttribute('colspan'), 10) - 1;
  });
  return additionalThCount;
}
/**
 * Create thead markdown.
 * @param {HTMLElement} theadElement - theadElement element
 * @param {string} theadContentMarkdown - thead markdown content
 * @returns {string}
 * @private
 */

function _createTheadMarkdown(theadElement, theadContentMarkdown) {
  var ths = toArray_default()(theadElement.querySelectorAll('th'));
  var align = ths.map(function (th) {
    return " " + _makeTableHeadAlignText(th) + " |";
  }).join('');
  align += _createRepeatString(' --- |', _getAdditionalThCount(ths));
  return theadContentMarkdown ? theadContentMarkdown + "|" + align + "\n" : '';
}
function createToMarkRenderer(baseRenderer) {
  var Renderer = Object.getPrototypeOf(baseRenderer).constructor;
  return Renderer.factory(baseRenderer, {
    THEAD: _createTheadMarkdown
  });
}
// EXTERNAL MODULE: ./node_modules/tui-code-snippet/collection/pluck.js
var pluck = __webpack_require__(13);
var pluck_default = /*#__PURE__*/__webpack_require__.n(pluck);

// EXTERNAL MODULE: ./node_modules/tui-code-snippet/domUtil/addClass.js
var addClass = __webpack_require__(8);
var addClass_default = /*#__PURE__*/__webpack_require__.n(addClass);

// EXTERNAL MODULE: ./node_modules/tui-code-snippet/domUtil/removeClass.js
var removeClass = __webpack_require__(17);
var removeClass_default = /*#__PURE__*/__webpack_require__.n(removeClass);

// CONCATENATED MODULE: ./src/js/tableRangeHandler.js
/**
 * @fileoverview Implements tableRangeHandler
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */





/**
 * Find unmerged table range.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {HTMLElement} start - start talbe cell element
 * @param {HTMLElement} end - end table cell element
 * @returns {{
 *   start: {rowIndex: number, colIndex: number},
 *   end: {rowIndex: number, colIndex: number}
 * }}
 * @private
 */

function _findUnmergedRange(tableData, start, end) {
  var cellIndexData = tableDataHandler.createCellIndexData(tableData);
  var startCellIndex = tableDataHandler.findCellIndex(cellIndexData, start);
  var endCellIndex = tableDataHandler.findCellIndex(cellIndexData, end);
  var startRowIndex, endRowIndex, startColIndex, endColIndex;

  if (startCellIndex.rowIndex > endCellIndex.rowIndex) {
    startRowIndex = endCellIndex.rowIndex;
    endRowIndex = startCellIndex.rowIndex;
  } else {
    startRowIndex = startCellIndex.rowIndex;
    endRowIndex = endCellIndex.rowIndex;
  }

  if (startCellIndex.colIndex > endCellIndex.colIndex) {
    startColIndex = endCellIndex.colIndex;
    endColIndex = startCellIndex.colIndex;
  } else {
    startColIndex = startCellIndex.colIndex;
    endColIndex = endCellIndex.colIndex;
  }

  return {
    start: {
      rowIndex: startRowIndex,
      colIndex: startColIndex
    },
    end: {
      rowIndex: endRowIndex,
      colIndex: endColIndex
    }
  };
}
/**
 * Expand table range by row merge properties like rowspan, rowMergeWith.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {{
 *   start: {rowIndex: number, colIndex: number},
 *   end: {rowIndex: number, colIndex: number}
 * }} tableRange - table range
 * @param {string} rangeType - range type like start, end
 * @private
 */


function _expandRowMergedRange(tableData, tableRange, rangeType) {
  var rowIndex = tableRange[rangeType].rowIndex;
  var rowData = tableData[rowIndex];
  range_default()(tableRange.start.colIndex, tableRange.end.colIndex + 1).forEach(function (colIndex) {
    var cellData = rowData[colIndex];
    var rowMergeWith = cellData.rowMergeWith;
    var lastRowMergedIndex = -1;

    if (isExisty_default()(rowMergeWith)) {
      if (rowMergeWith < tableRange.start.rowIndex) {
        tableRange.start.rowIndex = rowMergeWith;
      }

      lastRowMergedIndex = rowMergeWith + tableData[rowMergeWith][colIndex].rowspan - 1;
    } else if (cellData.rowspan > 1) {
      lastRowMergedIndex = rowIndex + cellData.rowspan - 1;
    }

    if (lastRowMergedIndex > tableRange.end.rowIndex) {
      tableRange.end.rowIndex = lastRowMergedIndex;
    }
  });
}
/**
 * Expand table range by column merge properties like colspan, colMergeWith.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {{
 *   start: {rowIndex: number, colIndex: number},
 *   end: {rowIndex: number, colIndex: number}
 * }} tableRange - table range
 * @param {number} rowIndex - row index
 * @param {number} colIndex - column index
 * @private
 */


function _expandColMergedRange(tableData, tableRange, rowIndex, colIndex) {
  var rowData = tableData[rowIndex];
  var cellData = rowData[colIndex];
  var colMergeWith = cellData.colMergeWith;
  var lastColMergedIndex = -1;

  if (isExisty_default()(colMergeWith)) {
    if (colMergeWith < tableRange.start.colIndex) {
      tableRange.start.colIndex = colMergeWith;
    }

    lastColMergedIndex = colMergeWith + rowData[colMergeWith].colspan - 1;
  } else if (cellData.colspan > 1) {
    lastColMergedIndex = colIndex + cellData.colspan - 1;
  }

  if (lastColMergedIndex > tableRange.end.colIndex) {
    tableRange.end.colIndex = lastColMergedIndex;
  }
}
/**
 * Expand table range by merge properties like colspan, rowspan.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {{
 *   start: {rowIndex: number, colIndex: number},
 *   end: {rowIndex: number, colIndex: number}
 * }} tableRange - table range
 * @returns {{
 *   start: {rowIndex: number, colIndex: number},
 *   end: {rowIndex: number, colIndex: number}
 * }}
 * @private
 */


function _expandMergedRange(tableData, tableRange) {
  var rangeStr = '';

  while (rangeStr !== JSON.stringify(tableRange)) {
    rangeStr = JSON.stringify(tableRange);

    _expandRowMergedRange(tableData, tableRange, 'start');

    _expandRowMergedRange(tableData, tableRange, 'end');

    range_default()(tableRange.start.rowIndex, tableRange.end.rowIndex + 1).forEach(function (rowIndex) {
      _expandColMergedRange(tableData, tableRange, rowIndex, tableRange.start.colIndex);

      _expandColMergedRange(tableData, tableRange, rowIndex, tableRange.end.colIndex);
    });
  }

  return tableRange;
}
/**
 * Find table range for selection.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {HTMLElement} start - start element
 * @param {HTMLElement} end - end element
 * @returns {{
 *   start: {rowIndex: number, colIndex: number},
 *   end: {rowIndex: number, colIndex: number}
 * }}
 * @ignore
 */


function findSelectionRange(tableData, start, end) {
  var unmergedRange = _findUnmergedRange(tableData, start, end);

  return _expandMergedRange(tableData, unmergedRange);
}
/**
 * Get table selection range.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {HTMLElement} selectedCells - selected cells elements
 * @param {HTMLElement} startContainer - start container element of text range
 * @returns {{
 *   start: {rowIndex: number, colIndex: number},
 *   end: {rowIndex: number, colIndex: number}
 *}}
 * @ignore
 */


function getTableSelectionRange(tableData, selectedCells, startContainer) {
  var cellIndexData = tableDataHandler.createCellIndexData(tableData);
  var tableRange = {};

  if (selectedCells.length) {
    var startRange = tableDataHandler.findCellIndex(cellIndexData, selectedCells[0]);
    var endRange = extend_default()({}, startRange);
    toArray_default()(selectedCells).forEach(function (cell) {
      var cellIndex = tableDataHandler.findCellIndex(cellIndexData, cell);
      var cellData = tableData[cellIndex.rowIndex][cellIndex.colIndex];
      var lastRowMergedIndex = cellIndex.rowIndex + cellData.rowspan - 1;
      var lastColMergedIndex = cellIndex.colIndex + cellData.colspan - 1;
      endRange.rowIndex = Math.max(endRange.rowIndex, lastRowMergedIndex);
      endRange.colIndex = Math.max(endRange.colIndex, lastColMergedIndex);
    });
    tableRange.start = startRange;
    tableRange.end = endRange;
  } else {
    var cellIndex = tableDataHandler.findCellIndex(cellIndexData, startContainer);
    tableRange.start = cellIndex;
    tableRange.end = extend_default()({}, cellIndex);
  }

  return tableRange;
}

/* harmony default export */ var tableRangeHandler = ({
  findSelectionRange: findSelectionRange,
  getTableSelectionRange: getTableSelectionRange
});
// CONCATENATED MODULE: ./src/js/wwMergedTableManager.js
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileoverview Implements wysiwyg merged table manager
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */










var PASTE_TABLE_BOOKMARK = 'tui-paste-table-bookmark';
var PASTE_TABLE_CELL_BOOKMARK = 'tui-paste-table-cell-bookmark';
/**
 * Whether one of them is true or not.
 * @param {Array} arr - target array
 * @param {function} contition - condition function
 * @returns {boolean}
 * @ignore
 */

function any(arr, contition) {
  var result = false;
  forEach_default()(arr, function (item) {
    result = contition(item);
    return !result;
  });
  return result;
}
/**
 * Get class WwMergedTableManager
 * @param {Editor} editor - editor instance
 * @returns {WwMergedTableManager} class of table manager
 */


function getWwMergedTableManager(editor) {
  var WwTableManager = Object.getPrototypeOf(editor).constructor.WwTableManager;
  var i18n = editor.i18n;
  /**
   * Class WwMergedTableManager
   * @ignore
   */

  return (/*#__PURE__*/function (_WwTableManager) {
      _inheritsLoose(WwMergedTableManager, _WwTableManager);

      function WwMergedTableManager() {
        return _WwTableManager.apply(this, arguments) || this;
      }

      var _proto = WwMergedTableManager.prototype;

      /**
       * Update mergeWidth property like rowMergeWith, colMergeWith of table data for copy.
       * @param {Array.<Array.<object>>} copyTableData - table data for copy
       * @param {{rowIndex: number, colIndex: number}} startRange - start range
       * @private
       */
      _proto._updateCopyDataMergeWith = function _updateCopyDataMergeWith(copyTableData, startRange) {
        copyTableData.forEach(function (rowData) {
          rowData.forEach(function (cellData) {
            if (isExisty_default()(cellData.rowMergeWith)) {
              cellData.rowMergeWith -= startRange.rowIndex;
            }

            if (isExisty_default()(cellData.colMergeWith)) {
              cellData.colMergeWith -= startRange.colIndex;
            }
          });
        });
      }
      /**
       * Create table data for copy.
       * @param {Array.<Array.<object>>} tableData - table data
       * @param {{rowIndex: number, colIndex: number}} startRange - start range
       * @param {{rowIndex: number, colIndex: number}} endRange - end range
       * @returns {Array.<Array.<object>>}
       * @private
       */
      ;

      _proto._createCopyTableData = function _createCopyTableData(tableData, startRange, endRange) {
        var copyTableData = tableData.slice(startRange.rowIndex, endRange.rowIndex + 1);
        copyTableData = copyTableData.map(function (rowData) {
          return rowData.slice(startRange.colIndex, endRange.colIndex + 1);
        });

        this._updateCopyDataMergeWith(copyTableData, startRange);

        return copyTableData;
      }
      /**
       * Update table html of clipboard data, if has selected cells.
       * @param {HTMLElement} clipboardContainer - clipboard element
       * @override
       */
      ;

      _proto.updateTableHtmlOfClipboardIfNeed = function updateTableHtmlOfClipboardIfNeed(clipboardContainer) {
        var selectedCells = this.wwe.componentManager.getManager('tableSelection').getSelectedCells();

        if (selectedCells.length) {
          var tableData = tableDataHandler.createTableData(closest_default()(selectedCells[0], 'TABLE'));

          var _tableRangeHandler$ge = tableRangeHandler.getTableSelectionRange(tableData, selectedCells),
              startRange = _tableRangeHandler$ge.start,
              endRange = _tableRangeHandler$ge.end;

          var copyTableData = this._createCopyTableData(tableData, startRange, endRange);

          var cellIndexData = tableDataHandler.createCellIndexData(copyTableData);
          var renderData = tableDataHandler.createRenderData(copyTableData, cellIndexData);
          clipboardContainer.innerHTML = tableRenderer.createTableHtml(renderData);
        }
      }
      /**
       * Prepare to table cell stuffing
       * @param {Array.<Array.<object>>} tableData - table data
       * @returns {{maximumCellLength: *, needTableCellStuffingAid: boolean}}
       * @override
       */
      ;

      _proto.prepareToTableCellStuffing = function prepareToTableCellStuffing(tableData) {
        var maximumCellLength = tableData[0].length;
        var needTableCellStuffingAid = false;
        tableData.slice(1).forEach(function (rowData) {
          var cellCount = rowData.length;

          if (maximumCellLength !== cellCount) {
            needTableCellStuffingAid = true;

            if (maximumCellLength < cellCount) {
              maximumCellLength = cellCount;
            }
          }
        });
        return {
          maximumCellLength: maximumCellLength,
          needTableCellStuffingAid: needTableCellStuffingAid
        };
      }
      /**
       * Append table cells.
       * @param {HTMLElement} node Table element
       * @override
       */
      ;

      _proto.tableCellAppendAidForTableElement = function tableCellAppendAidForTableElement(node) {
        var table = node;
        var tableData = tableDataHandler.createTableData(table);
        var added = tableDataHandler.addTbodyOrTheadIfNeed(tableData);
        var tableAidInformation = this.prepareToTableCellStuffing(tableData);
        var needTableCellStuffingAid = tableAidInformation.needTableCellStuffingAid;

        if (needTableCellStuffingAid) {
          tableDataHandler.stuffCellsIntoIncompleteRow(tableData, tableAidInformation.maximumCellLength);
        }

        if (added || needTableCellStuffingAid) {
          tableRenderer.replaceTable(table, tableData);
        }
      }
      /**
       * Find start cell.
       * @param {HTMLElement} selectedCells - elements like td, th
       * @returns {HTMLElement}
       * @private
       */
      ;

      _proto._findStartCell = function _findStartCell(selectedCells) {
        var startCell;

        if (selectedCells.length === 1) {
          startCell = selectedCells[0];
        } else {
          startCell = this.wwe.getEditor().getSelection().startContainer;
        }

        return startCell;
      }
      /**
       * Find start cell index.
       * @param {Array.<Array.<object>>} tableData - table data
       * @param {HTMLElement} startCell - start element like td, th
       * @returns {{rowIndex: number, colIndex: number}}
       * @private
       */
      ;

      _proto._findStartCellIndex = function _findStartCellIndex(tableData, startCell) {
        var cellIndexData = tableDataHandler.createCellIndexData(tableData);
        return tableDataHandler.findCellIndex(cellIndexData, startCell);
      }
      /**
       * Whether has row merged header in clipboardTableData.
       * @param {Array.<Array.<object>>} clipboardTableData - table data of clipboard
       * @param {Array.<Array.<object>>} tableData - table data
       * @param {{rowIndex: number, colIndex: number}} startCellIndex - start cell index
       * @returns {boolean}
       * @private
       */
      ;

      _proto._hasRowMergedHeader = function _hasRowMergedHeader(clipboardTableData, tableData, startCellIndex) {
        var isHeader = tableData[startCellIndex.rowIndex][startCellIndex.colIndex].nodeName === 'TH';
        var hasHeaderMerge = any(clipboardTableData[0], function (cellData) {
          return cellData.rowspan && cellData.rowspan > 1;
        });
        return isHeader && hasHeaderMerge;
      }
      /**
       * Whether exactly fit table selection by clipboardTableData.
       * @param {Array.<Array.<object>>} clipboardTableData - table data of clipboard
       * @param {number} targetRowCount - target row count
       * @param {number} targetColCount - target col count
       * @returns {boolean}
       * @private
       */
      ;

      _proto._isExactlyFit = function _isExactlyFit(clipboardTableData, targetRowCount, targetColCount) {
        return targetRowCount % clipboardTableData.length === 0 && targetColCount % clipboardTableData[0].length === 0;
      }
      /**
       * Update clibpard table data.
       * @param {Array.<Array.<object>>} clipboardTableData - table data of clipboard
       * @param {number} targetRowCount - target row count
       * @param {number} targetColCount - target col count
       * @private
       */
      ;

      _proto._updateClipboardTableData = function _updateClipboardTableData(clipboardTableData, targetRowCount, targetColCount) {
        var clipboardRowCount = clipboardTableData.length;
        var clipboardColCount = clipboardTableData[0].length;
        var increaseRowCount = parseInt(targetRowCount / clipboardRowCount, 10);
        var increaseColCount = parseInt(targetColCount / clipboardColCount, 10);

        if (increaseRowCount > 1) {
          var originalData = JSON.parse(JSON.stringify(clipboardTableData));
          range_default()(0, increaseRowCount - 1).forEach(function () {
            var newRows = JSON.parse(JSON.stringify(originalData));
            clipboardTableData.push.apply(clipboardTableData, newRows);
          });
        }

        if (increaseColCount > 1) {
          var _originalData = JSON.parse(JSON.stringify(clipboardTableData));

          range_default()(0, increaseColCount - 1).forEach(function () {
            var newData = JSON.parse(JSON.stringify(_originalData));
            clipboardTableData.forEach(function (rowData, rowIndex) {
              rowData.push.apply(rowData, newData[rowIndex]);
            });
          });
        }
      }
      /**
       * Update table data by cliboard table data.
       * @param {Array.<Array.<object>>} clipboardTableData - table data of clipboard
       * @param {Array.<Array.<object>>} tableData - table data
       * @param {{rowIndex: number, colIndex: number}} startCellIndex - start cell index
       * @private
       */
      ;

      _proto._updateTableDataByClipboardData = function _updateTableDataByClipboardData(clipboardTableData, tableData, startCellIndex) {
        var startRowIndex = startCellIndex.rowIndex;
        var startColIndex = startCellIndex.colIndex;
        clipboardTableData.forEach(function (rowData, rowIndex) {
          var updateRowIndex = startRowIndex + rowIndex;
          rowData.forEach(function (cellData, colIndex) {
            var updateColIndex = startColIndex + colIndex;
            var prevCellData = tableData[updateRowIndex][updateColIndex];
            cellData.nodeName = prevCellData.nodeName;
            tableData[updateRowIndex][updateColIndex] = cellData;
          });
        });
      }
      /**
       * Whether possible to paste or not.
       * @param {Array.<Array.<object>>} tableData - table data
       * @param {{rowIndex: number, colIndex: number}} startCellIndex - start cell index
       * @param {{rowIndex: number, colIndex: number}} endCellIndex - end cell index
       * @returns {boolean}
       * @private
       */
      ;

      _proto._isPossibleToPaste = function _isPossibleToPaste(tableData, startCellIndex, endCellIndex) {
        var startRowIndex = startCellIndex.rowIndex;
        var startColIndex = startCellIndex.colIndex;
        var endRowIndex = endCellIndex.rowIndex;
        var endColIndex = endCellIndex.colIndex;
        var filterdTableData = tableData.slice(startRowIndex, endRowIndex + 1);
        var firstRow = filterdTableData[0].slice(startColIndex, endColIndex + 1);
        var isPossible = !any(firstRow, function (cellData) {
          return isExisty_default()(cellData.rowMergeWith);
        });

        if (isPossible) {
          var firstCells = pluck_default()(filterdTableData, startColIndex);
          isPossible = !any(firstCells, function (cellData) {
            return isExisty_default()(cellData.colMergeWith);
          });
        }

        if (isPossible && tableData.length > endRowIndex + 1) {
          var nextRow = tableData[endRowIndex + 1].slice(startColIndex, endColIndex + 1);
          isPossible = !any(nextRow, function (cellData) {
            return isExisty_default()(cellData.rowMergeWith);
          });
        }

        if (isPossible && tableData[0].length > endColIndex + 1) {
          var nextCells = pluck_default()(filterdTableData, endColIndex + 1);
          isPossible = !any(nextCells, function (cellData) {
            return isExisty_default()(cellData.colMergeWith);
          });
        }

        return isPossible;
      }
      /**
       * Splice clipboardTableData by target row count and col count.
       * @param {Array.<Array.<object>>} clipboardTableData - table data of clipboard
       * @param {number} targetRowCount - target row count
       * @param {number} targetColCount - target col count
       * @private
       */
      ;

      _proto._spliceClipboardData = function _spliceClipboardData(clipboardTableData, targetRowCount, targetColCount) {
        clipboardTableData.splice(targetRowCount);
        clipboardTableData.forEach(function (rowData) {
          rowData.splice(targetColCount);
        });
      }
      /**
       * bookmark last td.
       * @param {number} endRowIndex - end row index
       * @param {number} endColIndex - end col index
       * @private
       */
      ;

      _proto._bookmarkLastTd = function _bookmarkLastTd(_ref) {
        var endRowIndex = _ref.rowIndex,
            endColIndex = _ref.colIndex;
        var sq = this.wwe.getEditor();
        var bookmarkedTable = sq.getBody().querySelector("." + PASTE_TABLE_BOOKMARK);
        var tableData = tableDataHandler.createTableData(bookmarkedTable);
        var lastCellData = tableData[endRowIndex][endColIndex];
        endRowIndex = isExisty_default()(lastCellData.rowMergeWith) ? lastCellData.rowMergeWith : endRowIndex;
        endColIndex = isExisty_default()(lastCellData.colMergeWith) ? lastCellData.colMergeWith : endColIndex;
        var lastCellIndex = tableData[endRowIndex][endColIndex].elementIndex;
        var foundTr = bookmarkedTable.querySelectorAll('tr')[lastCellIndex.rowIndex];
        var lastTd = foundTr.children[lastCellIndex.colIndex];
        removeClass_default()(bookmarkedTable, PASTE_TABLE_BOOKMARK);
        addClass_default()(lastTd, PASTE_TABLE_CELL_BOOKMARK);
      }
      /**
       * Update clipboard data for paste to smaller selection area than clipboard data.
       * @param {Array.<Array.<object>>} clipboardTableData - table data of clipboard
       * @param {Array.<Array.<object>>} tableData - table data
       * @param {number} targetRowCount - target row count
       * @param {number} targetColCount - target col count
       * @param {{rowIndex: number, colIndex: number}} startRange - start table range
       * @returns {boolean}
       * @private
       */
      ;

      _proto._updateClipboardDataForPasteToSamllerSelectedArea = function _updateClipboardDataForPasteToSamllerSelectedArea(clipboardTableData, tableData, targetRowCount, targetColCount, startRange) {
        var updated = true;
        var startCellIndex = {
          rowIndex: 0,
          colIndex: 0
        };
        var endCellIndex = {
          rowIndex: targetRowCount - 1,
          colIndex: targetColCount - 1
        };

        if (this._isPossibleToPaste(clipboardTableData, startCellIndex, endCellIndex)) {
          this._spliceClipboardData(clipboardTableData, targetRowCount, targetColCount);

          this._updateTableDataByClipboardData(clipboardTableData, tableData, startRange);
        } else {
          updated = false;
        }

        return updated;
      }
      /**
       * Paste to selected area.
       * @param {HTMLElement} table - target table element
       * @param {Array.<Array.<object>>} clipboardTableData - table data of clipboard
       * @param {Array.<Array.<object>>} tableData - table data
       * @param {HTMLElement} selectedCells - selected elements like td, th
       * @private
       */

      /* eslint-disable complexity */
      ;

      _proto._pasteToSelectedArea = function _pasteToSelectedArea(table, clipboardTableData, tableData, selectedCells) {
        var _tableRangeHandler$ge2 = tableRangeHandler.getTableSelectionRange(tableData, selectedCells),
            startRange = _tableRangeHandler$ge2.start,
            endRange = _tableRangeHandler$ge2.end;

        var targetRowCount = endRange.rowIndex - startRange.rowIndex + 1;
        var targetColCount = endRange.colIndex - startRange.colIndex + 1;
        var clipboardRowCount = clipboardTableData.length;
        var clipboardColCount = clipboardTableData[0].length;
        var isSelectionLargerThanData = targetRowCount >= clipboardRowCount && targetColCount >= clipboardColCount;
        var alertMessage = i18n.get('Cannot change part of merged cell');
        var updated = true;
        var endCellIndex;

        if (this._hasRowMergedHeader(clipboardTableData, tableData, startRange)) {
          alertMessage = i18n.get('Cannot paste row merged cells into the table header');
          updated = false;
        } else if (this._isExactlyFit(clipboardTableData, targetRowCount, targetColCount)) {
          endCellIndex = endRange;

          this._updateClipboardTableData(clipboardTableData, targetRowCount, targetColCount);

          this._updateTableDataByClipboardData(clipboardTableData, tableData, startRange);
        } else if (isSelectionLargerThanData) {
          endCellIndex = {
            rowIndex: startRange.rowIndex + clipboardRowCount - 1,
            colIndex: startRange.colIndex + clipboardColCount - 1
          };

          if (this._isPossibleToPaste(tableData, startRange, endCellIndex)) {
            this._updateTableDataByClipboardData(clipboardTableData, tableData, startRange);
          } else {
            updated = false;
          }
        } else {
          // selected area is smaller then paste data
          endCellIndex = {
            rowIndex: startRange.rowIndex + targetRowCount - 1,
            colIndex: startRange.colIndex + targetColCount - 1
          };
          updated = this._updateClipboardDataForPasteToSamllerSelectedArea(clipboardTableData, tableData, targetRowCount, targetColCount, startRange);
        }

        if (updated) {
          tableData.className += " " + PASTE_TABLE_BOOKMARK;
          tableRenderer.replaceTable(table, tableData);

          this._bookmarkLastTd(endCellIndex);
        } else {
          alert(alertMessage);
          this.wwe.focus();
        }
      }
      /**
       * Find end cell index.
       * @param {Array.<Array.<object>>} clipboardTableData - table data of clipboard
       * @param {number} startRowIndex - start row index
       * @param {number} startColIndex - start col index
       * @returns {{rowIndex: number, colIndex: number}}
       * @private
       */
      ;

      _proto._findEndCellIndex = function _findEndCellIndex(clipboardTableData, _ref2) {
        var startRowIndex = _ref2.rowIndex,
            startColIndex = _ref2.colIndex;
        return {
          rowIndex: startRowIndex + clipboardTableData.length - 1,
          colIndex: startColIndex + clipboardTableData[0].length - 1
        };
      }
      /**
       * Expand row.
       * @param {Array.<Array.<object>>} tableData - table data
       * @param {number} expandCount - expand count
       * @private
       */
      ;

      _proto._expandRow = function _expandRow(tableData, expandCount) {
        var startRowIndex = tableData.length;
        var cellCount = tableData[0].length;
        var newRows = range_default()(startRowIndex, startRowIndex + expandCount).map(function (rowIndex) {
          return range_default()(0, cellCount).map(function (colIndex) {
            return tableDataHandler.createBasicCell(rowIndex, colIndex);
          });
        });
        tableData.push.apply(tableData, newRows);
      }
      /**
       * Expand column.
       * @param {Array.<Array.<object>>} tableData - table data
       * @param {number} expandCount - expand count
       * @private
       */
      ;

      _proto._expandCoumn = function _expandCoumn(tableData, expandCount) {
        var startCellIndex = tableData[0].length;
        var additionalCellRange = range_default()(startCellIndex, startCellIndex + expandCount);
        tableData.forEach(function (rowData, rowIndex) {
          var nodeName = rowData[0].nodeName;
          var newCells = additionalCellRange.map(function (colIndex) {
            return tableDataHandler.createBasicCell(rowIndex, colIndex, nodeName);
          });
          rowData.push.apply(rowData, newCells);
        });
      }
      /**
       * Expand table data, if need.
       * @param {Array.<Array.<object>>} tableData - table data
       * @param {{rowIndex: number, colIndex: number}} startCellIndex - start cell index
       * @param {{rowIndex: number, colIndex: number}} endCellIndex - end cell index
       * @private
       */
      ;

      _proto._expandTableDataIfNeed = function _expandTableDataIfNeed(tableData, startCellIndex, endCellIndex) {
        var expandRowCount = endCellIndex.rowIndex - tableData.length + 1;
        var expandCellCount = endCellIndex.colIndex - tableData[0].length + 1;

        if (expandRowCount > 0) {
          this._expandRow(tableData, expandRowCount);
        }

        if (expandCellCount > 0) {
          this._expandCoumn(tableData, expandCellCount);
        }
      }
      /**
       * Paste all clipboard table data.
       * @param {HTMLElement} table - table element
       * @param {Array.<Array.<object>>} clipboardTableData - table data of clipboard
       * @param {Array.<Array.<object>>} tableData - table data
       * @param {{rowIndex: number, colIndex: number}} startCellIndex - start cell index
       * @private
       */
      ;

      _proto._pasteAllClipboardTableData = function _pasteAllClipboardTableData(table, clipboardTableData, tableData, startCellIndex) {
        var endCellIndex = this._findEndCellIndex(clipboardTableData, startCellIndex);

        if (this._hasRowMergedHeader(clipboardTableData, tableData, startCellIndex)) {
          alert(i18n.get('Cannot paste row merged cells into the table header'));
          this.wwe.focus();
          return;
        }

        this._expandTableDataIfNeed(tableData, startCellIndex, endCellIndex);

        if (this._isPossibleToPaste(tableData, startCellIndex, endCellIndex)) {
          this._updateTableDataByClipboardData(clipboardTableData, tableData, startCellIndex);

          tableData.className += " " + PASTE_TABLE_BOOKMARK;
          tableRenderer.replaceTable(table, tableData);

          this._bookmarkLastTd(endCellIndex);
        } else {
          alert(i18n.get('Cannot change part of merged cell'));
          this.wwe.focus();
        }
      }
      /**
       * Paste clibpard data.
       * @param {Node} clipboardTable - table element of clipboard
       */
      ;

      _proto.pasteTableData = function pasteTableData(clipboardTable) {
        var clipboardTableData = tableDataHandler.createTableData(clipboardTable);
        var tableSelectionManager = this.wwe.componentManager.getManager('tableSelection');
        var selectedCells = tableSelectionManager.getSelectedCells();

        var startCell = this._findStartCell(selectedCells);

        var table = closest_default()(startCell, 'table');
        var tableData = tableDataHandler.createTableData(table);

        var startCellIndex = this._findStartCellIndex(tableData, startCell);

        if (selectedCells.length > 1) {
          // selection
          this._pasteToSelectedArea(table, clipboardTableData, tableData, selectedCells);
        } else {
          // cursor
          this._pasteAllClipboardTableData(table, clipboardTableData, tableData, startCellIndex);
        }
      };

      return WwMergedTableManager;
    }(WwTableManager)
  );
}
// CONCATENATED MODULE: ./src/js/wwMergedTableSelectionManager.js
function wwMergedTableSelectionManager_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileoverview Implements wysiwyg merged table selection manager
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */






var TABLE_CELL_SELECTED_CLASS_NAME = 'te-cell-selected';
/**
 * Get class WwMergedTableSelectionManager
 * @param {Editor} editor - editor instance
 * @returns {WwMergedTableSelectionManager} class of table manager
 */

function getWwMergedTableSelectionManager(editor) {
  var WwTableSelectionManager = Object.getPrototypeOf(editor).constructor.WwTableSelectionManager;
  /**
   * Class WwMergedTableSelectionManager
   * @param {WysiwygEditor} wwe - WysiwygEditor instance
   * @ignore
   */

  return (/*#__PURE__*/function (_WwTableSelectionMana) {
      wwMergedTableSelectionManager_inheritsLoose(WwMergedTableSelectionManager, _WwTableSelectionMana);

      function WwMergedTableSelectionManager(wwe) {
        var _this;

        _this = _WwTableSelectionMana.call(this, wwe) || this;
        /**
         * table cache data
         * @type {Array.<Array.<Object>>}
         * @private
         */

        _this._tableData = null;
        _this.mergedTableSelectionManager = true;
        return _this;
      }
      /**
       * Add css class for selected cells.
       * @param {HTMLElement} table - table element
       * @param {Array.<Array.<object>>} tableData - table data
       * @param {{
       *   start: {rowIndex: number, colIndex: number},
       *   end: {rowIndex: number, colIndex: number}
       * }} tableRange - table selected range
       * @private
       */


      var _proto = WwMergedTableSelectionManager.prototype;

      _proto._addClassToSelectedCells = function _addClassToSelectedCells(table, tableData, tableRange) {
        var startRange = tableRange.start;
        var endRange = tableRange.end;
        var cellIndexRange = range_default()(startRange.colIndex, endRange.colIndex + 1);
        var trs = table.querySelectorAll('tr');
        range_default()(startRange.rowIndex, endRange.rowIndex + 1).forEach(function (rowIndex) {
          var rowData = tableData[rowIndex];
          var cells = trs[rowIndex].querySelectorAll('td, th');
          return cellIndexRange.forEach(function (colIndex) {
            var cellData = rowData[colIndex];

            if (cellData.elementIndex) {
              addClass_default()(cells[rowData[colIndex].elementIndex.colIndex], TABLE_CELL_SELECTED_CLASS_NAME);
            }
          });
        });
      }
      /**
       * cache table data on drag start
       * @param {HTMLElement} selectionStart - start element
       */
      ;

      _proto.onDragStart = function onDragStart(selectionStart) {
        var table = closest_default()(selectionStart, '[contenteditable=true] table');
        this._tableData = tableDataHandler.createTableData(table);
      }
      /**
       * clear table data in cache on drag end
       */
      ;

      _proto.onDragEnd = function onDragEnd() {
        this._tableData = null;
      }
      /**
       * Highlight selected table cells
       * @param {HTMLElement} selectionStart start element
       * @param {HTMLElement} selectionEnd end element
       * @override
       */
      ;

      _proto.highlightTableCellsBy = function highlightTableCellsBy(selectionStart, selectionEnd) {
        var start = selectionStart;
        var end = selectionEnd;
        var table = closest_default()(start, '[contenteditable=true] table');
        var tableRange = tableRangeHandler.findSelectionRange(this._tableData, start, end);
        this.removeClassAttrbuteFromAllCellsIfNeed();

        this._addClassToSelectedCells(table, this._tableData, tableRange);
      }
      /**
       * Style to selected cells.
       * @param {function} onStyle - function for styling
       * @param {Object} [options] - options to be passed into onStyle
       */
      ;

      _proto.styleToSelectedCells = function styleToSelectedCells(onStyle, options) {
        var sq = this.wwe.getEditor();
        var selectionRange = sq.getSelection().cloneRange();
        var table = closest_default()(selectionRange.startContainer, '[contenteditable=true] table');
        var trs = toArray_default()(table.querySelectorAll('tr'));
        trs.forEach(function (tr) {
          var cells = tr.querySelectorAll("." + TABLE_CELL_SELECTED_CLASS_NAME);

          if (!cells.length) {
            return;
          }

          var firstSelectedCell = cells[0];
          var lastSelectedCell = cells[cells.length - 1];
          selectionRange.setStart(firstSelectedCell, 0);
          selectionRange.setEnd(lastSelectedCell, lastSelectedCell.childNodes.length);
          sq.setSelection(selectionRange);
          onStyle(sq, options);
        });
      }
      /**
       * Whether has selected both TH and TD.
       * @param {HTMLElement} selectedCells - selected cells element
       * @returns {boolean}
       */
      ;

      _proto.hasSelectedBothThAndTd = function hasSelectedBothThAndTd(selectedCells) {
        selectedCells = selectedCells || this.getSelectedCells();
        var _selectedCells = selectedCells,
            firstCell = _selectedCells[0];
        var lastCell = selectedCells[selectedCells.length - 1];
        return firstCell.nodeName !== lastCell.nodeName;
      };

      return WwMergedTableSelectionManager;
    }(WwTableSelectionManager)
  );
}
// CONCATENATED MODULE: ./src/js/mergedTableAddRow.js
/**
 * @fileoverview Implements mergedTableAddRow. Add Row to selected table
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */







/**
 * Create row merged cell data.
 * @param {number} rowMergeWith - row merge with index
 * @returns {{
 *   nodeName: string,
 *   rowMergeWith: number
 * }}
 * @private
 */

function _createRowMergedCell(rowMergeWith) {
  return {
    nodeName: 'TD',
    rowMergeWith: rowMergeWith
  };
}
/**
 * Create new row.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {number} rowIndex - row index of table data
 * @returns {object}
 * @private
 */

/* eslint-disable complexity */


function _createNewRow(tableData, rowIndex) {
  var prevCell = null;
  return tableData[rowIndex].map(function (cellData, colIndex) {
    var newCell;

    if (isExisty_default()(cellData.rowMergeWith)) {
      var rowMergeWith = cellData.rowMergeWith;
      var merger = tableData[rowMergeWith][colIndex];
      var lastMergedRowIndex = rowMergeWith + merger.rowspan - 1;

      if (isExisty_default()(merger.colMergeWith) && prevCell) {
        newCell = extend_default()({}, prevCell);
      } else if (lastMergedRowIndex > rowIndex) {
        merger.rowspan += 1;
        newCell = extend_default()({}, cellData);
      }
    } else if (cellData.rowspan > 1) {
      cellData.rowspan += 1;
      newCell = _createRowMergedCell(rowIndex);
    }

    if (!newCell) {
      newCell = tableDataHandler.createBasicCell(rowIndex + 1, colIndex);
    }

    prevCell = newCell;
    return newCell;
  });
}
/**
 * Add row.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {{
 *   start: {rowIndex: number, colIndex: number},
 *   end: {rowIndex: number, colIndex: number}
 * }} tableRange - table selection range
 * @param {number} rowIndex - row index of table data
 * @param {number} colIndex - column index of tabld data
 * @private
 */

function _addRow(tableData, tableRange) {
  var startRowIndex = tableRange.start.rowIndex;
  var endRange = tableRange.end;
  var endRowIndex = tableDataHandler.findRowMergedLastIndex(tableData, endRange.rowIndex, endRange.colIndex);
  var newRows = range_default()(startRowIndex, endRowIndex + 1).map(function () {
    return _createNewRow(tableData, endRowIndex);
  });
  tableData.splice.apply(tableData, [endRowIndex + 1, 0].concat(newRows));
}
/**
 * Find focus td element.
 * @param {HTMLElement} newTable - changed table element
 * @param {number} rowIndex - row index of table data
 * @param {number} colIndex - column index of tabld data
 * @returns {HTMLElement}
 * @private
 */

function _findFocusTd(newTable, rowIndex, colIndex) {
  var tableData = tableDataHandler.createTableData(newTable);
  var newRowIndex = tableDataHandler.findRowMergedLastIndex(tableData, rowIndex, colIndex) + 1;
  var cellElementIndex = tableDataHandler.findElementIndex(tableData, newRowIndex, colIndex);
  var foundTr = newTable.querySelectorAll('tr')[cellElementIndex.rowIndex];
  return foundTr.querySelectorAll('td')[cellElementIndex.colIndex];
}
/**
 * Get command instance
 * @param {Editor} editor - editor instance
 * @returns {command} command to add row
 */


function getWwAddRowCommand(editor) {
  var CommandManager = Object.getPrototypeOf(editor).constructor.CommandManager;
  return CommandManager.command('wysiwyg',
  /** @lends AddRow */
  {
    name: 'AddRow',

    /**
     * Command handler.
     * @param {WysiwygEditor} wwe - wysiwygEditor instance
     */
    exec: function exec(wwe) {
      var sq = wwe.getEditor();
      var selectionRange = sq.getSelection().cloneRange();
      wwe.focus();

      if (!sq.hasFormat('TABLE')) {
        return;
      }

      var startContainer = selectionRange.startContainer;
      var startElement = startContainer.nodeType !== 1 ? startContainer.parentNode : startContainer;
      var table = closest_default()(startElement, 'table');
      var tableData = tableDataHandler.createTableData(table);
      var selectedCells = wwe.componentManager.getManager('tableSelection').getSelectedCells();
      var tableRange = tableRangeHandler.getTableSelectionRange(tableData, selectedCells, startContainer);
      sq.saveUndoState(selectionRange);

      _addRow(tableData, tableRange);

      var newTable = tableRenderer.replaceTable(table, tableData);

      var focusTd = _findFocusTd(newTable, tableRange.end.rowIndex, tableRange.start.colIndex);

      tableRenderer.focusToCell(sq, selectionRange, focusTd);
    }
  });
}
// CONCATENATED MODULE: ./src/js/mergedTableAddCol.js
/**
 * @fileoverview Implements mergedTableAddCol. Add Row to selected table.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */







/**
 * Create column merged cell.
 * @param {number} colMergeWith - column merge start index
 * @param {string} nodeName - node name
 * @returns {{
 *   nodeName: string,
 *   colMerged: boolean,
 *   colMergeWith: number
 * }}
 * @private
 */

function _createColMergedCell(colMergeWith, nodeName) {
  return {
    nodeName: nodeName,
    colMergeWith: colMergeWith
  };
}
/**
 * Create new cell data.
 * @param {Array.<object>} rowData - row data of table data
 * @param {number} rowIndex - row index of table data
 * @param {number} colIndex - column index of table data
 * @param {object | null} prevCell - previous cell data
 * @returns {object}
 * @private
 */

/* eslint-disable complexity */


function _createNewCell(rowData, rowIndex, colIndex, prevCell) {
  var cellData = rowData[colIndex];
  var newCell;

  if (isExisty_default()(cellData.colMergeWith)) {
    var colMergeWith = cellData.colMergeWith;
    var merger = rowData[colMergeWith];
    var lastMergedCellIndex = colMergeWith + merger.colspan - 1;

    if (isExisty_default()(merger.rowMergeWith) && prevCell) {
      newCell = extend_default()({}, prevCell);
    } else if (lastMergedCellIndex > colIndex) {
      merger.colspan += 1;
      newCell = extend_default()({}, cellData);
    }
  } else if (cellData.colspan > 1) {
    cellData.colspan += 1;
    newCell = _createColMergedCell(colIndex, cellData.nodeName);
  }

  if (!newCell) {
    newCell = tableDataHandler.createBasicCell(rowIndex, colIndex + 1, cellData.nodeName);
  }

  return newCell;
}
/**
 * Create new columns.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {number} startColIndex - start column index
 * @param {number} endColIndex - end column index
 * @returns {Array.<Array.<object>>}
 * @private
 */


function _createNewColumns(tableData, startColIndex, endColIndex) {
  var colIndexes = range_default()(startColIndex, endColIndex + 1);
  var newColumns = [];
  var prevCells = null;
  tableData.forEach(function (rowData, rowIndex) {
    var newCells = colIndexes.map(function (colIndex, index) {
      var prevCell = prevCells ? prevCells[index - 1] : null;
      return _createNewCell(rowData, rowIndex, endColIndex, prevCell);
    });
    prevCells = newCells;
    newColumns.push(newCells);
  });
  return newColumns;
}
/**
 * Add columns.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {{
 *   start: {rowIndex: number, colIndex: number},
 *   end: {rowIndex: number, colIndex: number}
 * }} tableRange - table selection range
 * @private
 */

function _addColumns(tableData, tableRange) {
  var endRange = tableRange.end;
  var endColIndex = tableDataHandler.findColMergedLastIndex(tableData, endRange.rowIndex, endRange.colIndex);

  var newColumns = _createNewColumns(tableData, tableRange.start.colIndex, endColIndex);

  var newColIndex = endColIndex + 1;
  tableData.forEach(function (rowData, rowIndex) {
    rowData.splice.apply(rowData, [newColIndex, 0].concat(newColumns[rowIndex]));
  });
}
/**
 * Find focus cell element like td or th.
 * @param {HTMLElement} newTable - changed table element
 * @param {number} rowIndex - row index of table data
 * @param {number} colIndex - column index of tabld data
 * @returns {HTMLElement}
 * @private
 */

function _findFocusCell(newTable, rowIndex, colIndex) {
  var tableData = tableDataHandler.createTableData(newTable);
  var newColIndex = tableDataHandler.findColMergedLastIndex(tableData, rowIndex, colIndex) + 1;
  var cellElementIndex = tableDataHandler.findElementIndex(tableData, rowIndex, newColIndex);
  var foundTr = newTable.querySelectorAll('tr')[cellElementIndex.rowIndex];
  return foundTr.querySelectorAll('td, th')[cellElementIndex.colIndex];
}
/**
 * Get command instance
 * @param {Editor} editor - editor instance
 * @returns {command} command to add column
 */


function getWwAddColumnCommand(editor) {
  var CommandManager = Object.getPrototypeOf(editor).constructor.CommandManager;

  if (CommandManager) {
    return CommandManager.command('wysiwyg',
    /** @lends AddCol */
    {
      name: 'AddCol',

      /**
       * Command handler.
       * @param {WysiwygEditor} wwe - wysiwygEditor instance
       */
      exec: function exec(wwe) {
        var sq = wwe.getEditor();
        var selectionRange = sq.getSelection().cloneRange();
        wwe.focus();

        if (!sq.hasFormat('TABLE')) {
          return;
        }

        var startContainer = selectionRange.startContainer;
        var startElement = startContainer.nodeType !== 1 ? startContainer.parentNode : startContainer;
        var table = closest_default()(startElement, 'table');
        var tableData = tableDataHandler.createTableData(table);
        var selectedCells = wwe.componentManager.getManager('tableSelection').getSelectedCells();
        var tableRange = tableRangeHandler.getTableSelectionRange(tableData, selectedCells, startContainer);
        sq.saveUndoState(selectionRange);

        _addColumns(tableData, tableRange);

        var newTable = tableRenderer.replaceTable(table, tableData);

        var focusCell = _findFocusCell(newTable, tableRange.start.rowIndex, tableRange.end.colIndex);

        tableRenderer.focusToCell(sq, selectionRange, focusCell);
      }
    });
  }

  return null;
}
// CONCATENATED MODULE: ./src/js/mergedTableRemoveRow.js
/**
 * @fileoverview Implements mergedTableRemoveRow
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */







/**
 * Update rowspan to row merger.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {number} startRowIndex - start row index
 * @param {number} endRowIndex - end row index
 * @private
 */

function _updateRowspan(tableData, startRowIndex, endRowIndex) {
  range_default()(startRowIndex, endRowIndex + 1).forEach(function (rowIndex) {
    tableData[rowIndex].forEach(function (cell, cellIndex) {
      if (isExisty_default()(cell.rowMergeWith)) {
        var merger = tableData[cell.rowMergeWith][cellIndex];

        if (merger.rowspan) {
          merger.rowspan -= 1;
        }
      } else if (cell.rowspan > 1) {
        var lastMergedRowIndex = rowIndex + cell.rowspan - 1;
        cell.rowspan -= endRowIndex - rowIndex + 1;

        if (lastMergedRowIndex > endRowIndex) {
          tableData[endRowIndex + 1][cellIndex] = extend_default()({}, cell);
        }
      }
    });
  });
}
/**
 * Update row merge start index to merged cell.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {number} startRowIndex - start row index
 * @param {number} endRowIndex - end row index
 * @private
 */


function _updateMergeStartIndex(tableData, startRowIndex, endRowIndex) {
  tableData.slice(endRowIndex + 1).forEach(function (row) {
    row.forEach(function (cell) {
      if (isExisty_default()(cell.rowMergeWith) && cell.rowMergeWith >= startRowIndex) {
        cell.rowMergeWith = endRowIndex + 1;
      }
    });
  });
}
/**
 * Remove row.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {{
 *   start: {rowIndex: number, colIndex: number},
 *   end: {rowIndex: number, colIndex: number}
 * }} tableRange - table selection range
 * @private
 */


function _removeRow(tableData, tableRange) {
  var startRowIndex = tableRange.start.rowIndex;
  var endRange = tableRange.end;
  var endRowIndex = tableDataHandler.findRowMergedLastIndex(tableData, endRange.rowIndex, endRange.colIndex);

  if (startRowIndex === 0 && endRowIndex === 0) {
    return;
  }

  startRowIndex = Math.max(startRowIndex, 1);
  endRowIndex = Math.max(endRowIndex, 1);
  var removeCount = endRowIndex - startRowIndex + 1; // if only table body or table header left, remove table

  if (tableData.length - removeCount < 2) {
    tableData.splice(0, tableData.length);
  } else {
    _updateRowspan(tableData, startRowIndex, endRowIndex);

    _updateMergeStartIndex(tableData, startRowIndex, endRowIndex);

    tableData.splice(startRowIndex, removeCount);
  }
}
/**
 * Find focus td element.
 * @param {HTMLElement} newTable - changed table element
 * @param {number} rowIndex - row index of table data
 * @param {number} colIndex - column index of tabld data
 * @returns {HTMLElement}
 * @private
 */

function mergedTableRemoveRow_findFocusTd(newTable, rowIndex, colIndex) {
  var tableData = tableDataHandler.createTableData(newTable);

  if (tableData.length - 1 < rowIndex) {
    rowIndex -= 1;
  }

  var cellElementIndex = tableDataHandler.findElementIndex(tableData, rowIndex, colIndex);
  var foundTr = newTable.querySelectorAll('tr')[cellElementIndex.rowIndex];
  return foundTr.querySelectorAll('th,td')[cellElementIndex.colIndex];
}
/**
 * Get command instance
 * @param {Editor} editor - editor instance
 * @returns {command} command to remove row
 */


function getWwRemoveRowCommand(editor) {
  var CommandManager = Object.getPrototypeOf(editor).constructor.CommandManager;
  return CommandManager.command('wysiwyg',
  /** @lends RemoveRow */
  {
    name: 'RemoveRow',

    /**
     * Command handler.
     * @param {WysiwygEditor} wwe - wysiwygEditor instance
     */
    exec: function exec(wwe) {
      var sq = wwe.getEditor();
      var selectionRange = sq.getSelection().cloneRange();
      wwe.focus();

      if (!sq.hasFormat('TABLE')) {
        return;
      }

      var startContainer = selectionRange.startContainer;
      var startElement = startContainer.nodeType !== 1 ? startContainer.parentNode : startContainer;
      var table = closest_default()(startElement, 'table');
      var tableData = tableDataHandler.createTableData(table);
      var beforeRowLength = tableData.length;
      var selectedCells = wwe.componentManager.getManager('tableSelection').getSelectedCells();
      var tableRange = tableRangeHandler.getTableSelectionRange(tableData, selectedCells, startContainer);
      sq.saveUndoState(selectionRange);

      _removeRow(tableData, tableRange);

      if (tableData.length < 2) {
        table.parentNode.removeChild(table);
      } else if (beforeRowLength !== tableData.length) {
        var newTable = tableRenderer.replaceTable(table, tableData);
        var startRowIndex = tableRange.start.rowIndex;
        var focusRowIndex = startRowIndex < tableData.length ? startRowIndex : startRowIndex - 1;

        var focusCell = mergedTableRemoveRow_findFocusTd(newTable, focusRowIndex, tableRange.start.colIndex);

        tableRenderer.focusToCell(sq, selectionRange, focusCell);
      }
    }
  });
}
// CONCATENATED MODULE: ./src/js/mergedTableRemoveCol.js
/**
 * @fileoverview Implements mergedTableRemoveCol. Remove col to selected table
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */







/**
 * Update colspan to col merger.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {number} startColIndex - start col index
 * @param {number} endColIndex - end col index
 * @private
 */

function _updateColspan(tableData, startColIndex, endColIndex) {
  tableData.forEach(function (rowData) {
    range_default()(startColIndex, endColIndex + 1).forEach(function (colIndex) {
      var cellData = rowData[colIndex];

      if (isExisty_default()(cellData.colMergeWith)) {
        var merger = rowData[cellData.colMergeWith];

        if (merger.colspan) {
          merger.colspan -= 1;
        }
      } else if (cellData.colspan > 1) {
        var lastMergedCellIndex = colIndex + cellData.colspan - 1;
        cellData.colspan -= endColIndex - colIndex + 1;

        if (lastMergedCellIndex > endColIndex) {
          rowData[endColIndex + 1] = extend_default()({}, cellData);
        }
      }
    });
  });
}
/**
 * Update row merge start index to merged cell.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {number} startColIndex - start col index
 * @param {number} endColIndex - end col index
 * @private
 */


function mergedTableRemoveCol_updateMergeStartIndex(tableData, startColIndex, endColIndex) {
  tableData.forEach(function (rowData) {
    rowData.slice(endColIndex + 1).forEach(function (cellData) {
      if (isExisty_default()(cellData.colMergeWith) && cellData.colMergeWith >= startColIndex) {
        cellData.colMergeWith = endColIndex + 1;
      }
    });
  });
}
/**
 * Remove columns.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {{
 *   start: {rowIndex: number, colIndex: number},
 *   end: {rowIndex: number, colIndex: number}
 * }} tableRange - table selection range
 * @private
 */


function _removeColumns(tableData, tableRange) {
  var startColIndex = tableRange.start.colIndex;
  var endRange = tableRange.end;
  var endColIndex = tableDataHandler.findColMergedLastIndex(tableData, endRange.rowIndex, endRange.colIndex);
  var removeCount = endColIndex - startColIndex + 1;

  _updateColspan(tableData, startColIndex, endColIndex);

  mergedTableRemoveCol_updateMergeStartIndex(tableData, startColIndex, endColIndex);

  tableData.forEach(function (row) {
    row.splice(startColIndex, removeCount);
  });
}
/**
 * Find focus cell element like td or th.
 * @param {HTMLElement} newTable - changed table element
 * @param {number} rowIndex - row index of table data
 * @param {number} colIndex - column index of tabld data
 * @returns {HTMLElement}
 * @private
 */

function mergedTableRemoveCol_findFocusCell(newTable, rowIndex, colIndex) {
  var tableData = tableDataHandler.createTableData(newTable);

  if (tableData[0].length - 1 < colIndex) {
    colIndex -= 1;
  }

  var cellElementIndex = tableDataHandler.findElementIndex(tableData, rowIndex, colIndex);
  var foundTr = newTable.querySelectorAll('tr')[cellElementIndex.rowIndex];
  return foundTr.querySelectorAll('td')[cellElementIndex.colIndex];
}
/**
 * Get command instance
 * @param {Editor} editor - editor instance
 * @returns {command} command to remove column
 */


function getWwRemoveColumnCommand(editor) {
  var CommandManager = Object.getPrototypeOf(editor).constructor.CommandManager;
  return CommandManager.command('wysiwyg',
  /** @lends RemoveCol */
  {
    name: 'RemoveCol',

    /**
     * Command handler.
     * @param {WysiwygEditor} wwe - wysiwygEditor instance
     */
    exec: function exec(wwe) {
      var sq = wwe.getEditor();
      var selectionRange = sq.getSelection().cloneRange();
      wwe.focus();

      if (!sq.hasFormat('TABLE')) {
        return;
      }

      var startContainer = selectionRange.startContainer;
      var startElement = startContainer.nodeType !== 1 ? startContainer.parentNode : startContainer;
      var table = closest_default()(startElement, 'table');
      var tableData = tableDataHandler.createTableData(table);
      var selectedCells = wwe.componentManager.getManager('tableSelection').getSelectedCells();
      var tableRange = tableRangeHandler.getTableSelectionRange(tableData, selectedCells, startContainer);
      var beforeCellLength = tableData[0].length;
      sq.saveUndoState(selectionRange);

      _removeColumns(tableData, tableRange);

      if (tableData[0].length === 0) {
        table.parentNode.removeChild(table);
      } else if (beforeCellLength !== tableData[0].length) {
        var newTable = tableRenderer.replaceTable(table, tableData);
        var startColIndex = tableRange.start.colIndex;
        var focusColIndex = startColIndex >= tableData[0].length ? startColIndex - 1 : startColIndex;

        var focusCell = mergedTableRemoveCol_findFocusCell(newTable, tableRange.start.rowIndex, focusColIndex);

        tableRenderer.focusToCell(sq, selectionRange, focusCell);
      }
    }
  });
}
// CONCATENATED MODULE: ./src/js/mergedTableAlignCol.js
/**
 * @fileoverview Implements mergedTableAlignCol. Align selected column's text content to given direction
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */






/**
 * Align to table header.
 * @param {Array.<object>} headRowData - head row data
 * @param {number} startColIndex - start column index for styling align
 * @param {number} endColIndex - end column index for styling align
 * @param {string} alignDirection - align direction
 * @private
 */

function _align(headRowData, startColIndex, endColIndex, alignDirection) {
  range_default()(startColIndex, endColIndex + 1).forEach(function (colIndex) {
    var headCellData = headRowData[colIndex];

    if (isExisty_default()(headCellData.colMergeWith)) {
      headRowData[headCellData.colMergeWith].align = alignDirection;
    } else {
      headCellData.align = alignDirection;
    }
  });
}
/**
 * Find focus cell element like td or th.
 * @param {HTMLElement} newTable - changed table  element
 * @param {HTMLElement} startContainer - start container element of text range
 * @returns {HTMLElement}
 * @private
 */


function mergedTableAlignCol_findFocusCell(newTable, startContainer) {
  var elementRowIndex = tableDataHandler.findElementRowIndex(startContainer);
  var elementColIndex = tableDataHandler.findElementColIndex(startContainer);
  var foundTr = newTable.querySelectorAll('tr')[elementRowIndex];
  return foundTr.querySelectorAll('td, th')[elementColIndex];
}
/**
 * Get command instance
 * @param {Editor} editor - editor instance
 * @returns {command} command to align column
 */


function getWwAlignColumnCommand(editor) {
  var CommandManager = Object.getPrototypeOf(editor).constructor.CommandManager;
  return CommandManager.command('wysiwyg',
  /** @lends AlignCol */
  {
    name: 'AlignCol',

    /**
     * Command handler.
     * @param {WysiwygEditor} wwe - wysiwygEditor instance
     * @param {string} alignDirection - align direction for table header
     */
    exec: function exec(wwe, alignDirection) {
      var sq = wwe.getEditor();
      var selectionRange = sq.getSelection().cloneRange();
      wwe.focus();

      if (!sq.hasFormat('TABLE')) {
        return;
      }

      var startContainer = selectionRange.startContainer;
      var startElement = startContainer.nodeType !== 1 ? startContainer.parentNode : startContainer;
      var table = closest_default()(startElement, 'table');
      var tableData = tableDataHandler.createTableData(table);
      var selectedCells = wwe.componentManager.getManager('tableSelection').getSelectedCells();
      var tableRange = tableRangeHandler.getTableSelectionRange(tableData, selectedCells, startContainer);

      _align(tableData[0], tableRange.start.colIndex, tableRange.end.colIndex, alignDirection);

      var newTable = tableRenderer.replaceTable(table, tableData);

      var focusCell = mergedTableAlignCol_findFocusCell(newTable, startContainer);

      tableRenderer.focusToCell(sq, selectionRange, focusCell);
    }
  });
}
// CONCATENATED MODULE: ./src/js/mergeCell.js
/**
 * @fileoverview Implements MergeCell
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */






var mergeCell_BASIC_CELL_CONTENT = browser["msie"] ? '' : '<br>';
/**
 * Pick merger content from selected cells.
 * @param {Array.<Array.<object>>} targetRows - target rows
 * @param {number} startColIndex - start column index
 * @param {number} endColIndex - end column index
 * @returns {string}
 * @private
 */

function _pickContent(targetRows, startColIndex, endColIndex) {
  var _ref;

  var limitColIndex = endColIndex + 1;

  var cells = (_ref = []).concat.apply(_ref, targetRows.map(function (rowData) {
    return rowData.slice(startColIndex, limitColIndex);
  }));

  var foundCellData = cells.filter(function (_ref2) {
    var content = _ref2.content;
    return content && content !== mergeCell_BASIC_CELL_CONTENT;
  });
  return foundCellData.length ? foundCellData[0].content : mergeCell_BASIC_CELL_CONTENT;
}
/**
 * Initialize cell data of target rows.
 * @param {Array.<Array.<object>>} targetRows - target rows
 * @param {number} startColIndex - start column index
 * @param {number} endColIndex - end column index
 * @private
 */


function _initCellData(targetRows, startColIndex, endColIndex) {
  var _ref3;

  var limitColIndex = endColIndex + 1;
  var targetCells = targetRows.map(function (rowData) {
    return rowData.slice(startColIndex, limitColIndex);
  });

  (_ref3 = []).concat.apply(_ref3, targetCells).slice(1).forEach(function (cellData) {
    var nodeName = cellData.nodeName;
    forEach_default()(cellData, function (value, name) {
      return delete cellData[name];
    });
    cellData.nodeName = nodeName;
  });
}
/**
 * Update rowMergeWith property of target rows for row merge.
 * @param {Array.<Array.<object>>} targetRows - target rows
 * @param {number} startColIndex - start column index
 * @param {number} endColIndex - end column index
 * @param {number} rowMergeWith - index of row merger
 * @private
 */


function _updateRowMergeWith(targetRows, startColIndex, endColIndex, rowMergeWith) {
  var limitColIndex = endColIndex + 1;
  targetRows.forEach(function (rowData) {
    rowData.slice(startColIndex, limitColIndex).forEach(function (cellData) {
      cellData.rowMergeWith = rowMergeWith;
    });
  });
}
/**
 * Update colMergeWith property of target rows for column merge.
 * @param {Array.<Array.<object>>} targetRows - target rows
 * @param {number} startColIndex - start column index
 * @param {number} endColIndex - end column index
 * @param {number} colMergeWith - index of column merger
 * @private
 */


function _updateColMergeWith(targetRows, startColIndex, endColIndex, colMergeWith) {
  var limitColIndex = endColIndex + 1;
  targetRows.forEach(function (rowData) {
    rowData.slice(startColIndex, limitColIndex).forEach(function (cellData) {
      cellData.colMergeWith = colMergeWith;
    });
  });
}
/**
 * Merge selected cells.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {{rowIndex: number, colIndex: number}} startRange - start table selection range
 * @param {{rowIndex: number, colIndex: number}} endRange - end table selection range
 * @private
 */


function _mergeCells(tableData, _ref4) {
  var startRange = _ref4.start,
      endRange = _ref4.end;
  var startRowIndex = startRange.rowIndex;
  var startColIndex = startRange.colIndex;
  var endRowIndex = endRange.rowIndex;
  var endColIndex = endRange.colIndex;
  var merger = tableData[startRowIndex][startColIndex];
  var targetRows = tableData.slice(startRowIndex, endRowIndex + 1);
  var rowspan = endRowIndex - startRowIndex + 1;
  var colspan = endColIndex - startColIndex + 1;
  merger.rowspan = rowspan;
  merger.colspan = colspan;
  merger.content = _pickContent(targetRows, startColIndex, endColIndex);

  _initCellData(targetRows, startColIndex, endColIndex);

  if (rowspan > 1) {
    _updateRowMergeWith(targetRows.slice(1), startColIndex, endColIndex, startRowIndex);
  }

  if (colspan > 1) {
    _updateColMergeWith(targetRows, startColIndex + 1, endColIndex, startColIndex);
  }
}
/**
 * Find focus cell element like td or th.
 * @param {HTMLElement} newTable - changed table element
 * @param {number} rowIndex - row index of table data
 * @param {number} colIndex - column index of tabld data
 * @returns {HTMLElement}
 * @private
 */

function mergeCell_findFocusCell(newTable, rowIndex, colIndex) {
  var tableData = tableDataHandler.createTableData(newTable);
  var cellElementIndex = tableDataHandler.findElementIndex(tableData, rowIndex, colIndex);
  var foundTr = newTable.querySelectorAll('tr')[cellElementIndex.rowIndex];
  return foundTr.querySelectorAll('td, th')[cellElementIndex.colIndex];
}
/**
 * Get command instance
 * @param {Editor} editor - editor instance
 * @returns {command} command to merge cell
 */


function getMergeCellCommand(editor) {
  var CommandManager = Object.getPrototypeOf(editor).constructor.CommandManager;
  return CommandManager.command('wysiwyg',
  /** @lends MergeCell */
  {
    name: 'MergeCells',

    /**
     * Command handler.
     * @param {WysiwygEditor} wwe - wysiwygEditor instance
     */
    exec: function exec(wwe) {
      var sq = wwe.getEditor();
      wwe.focus();

      if (!sq.hasFormat('TABLE')) {
        return;
      }

      var selectionManager = wwe.componentManager.getManager('tableSelection');
      var selectedCells = selectionManager.getSelectedCells();

      if (selectedCells.length < 2 || selectionManager.hasSelectedBothThAndTd(selectedCells)) {
        return;
      }

      var range = sq.getSelection().cloneRange();
      var startContainer = range.startContainer;
      var startElement = startContainer.nodeType !== 1 ? startContainer.parentNode : startContainer;
      var table = closest_default()(startElement, 'table');
      var tableData = tableDataHandler.createTableData(table);
      var tableRange = tableRangeHandler.getTableSelectionRange(tableData, selectedCells, startContainer);

      _mergeCells(tableData, tableRange);

      var newTable = tableRenderer.replaceTable(table, tableData);

      var focusCell = mergeCell_findFocusCell(newTable, tableRange.start.rowIndex, tableRange.start.colIndex);

      tableRenderer.focusToCell(sq, range, focusCell);
    }
  });
}
// CONCATENATED MODULE: ./src/js/unmergeCell.js
/**
 * @fileoverview Implements UnmergeCell
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */





/**
 * Whether has merged cell.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {{rowIndex: number, colIndex: number}} startRange - start table selection range
 * @param {{rowIndex: number, colIndex: number}} endRange - end table selection range
 * @returns {boolean}
 * @private
 */

function _hasMergedCell(tableData, _ref) {
  var _ref2;

  var startRange = _ref.start,
      endRange = _ref.end;
  var startColIndex = startRange.colIndex;
  var limitColIndex = endRange.colIndex + 1;
  var targetRows = tableData.slice(startRange.rowIndex, endRange.rowIndex + 1);
  var targetCells = targetRows.map(function (rowData) {
    return rowData.slice(startColIndex, limitColIndex);
  });
  return !!(_ref2 = []).concat.apply(_ref2, targetCells).filter(function (cellData) {
    return cellData.colspan > 1 || cellData.rowspan > 1;
  }).length;
}
/**
 * Update merged cell data to basic cell data.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {number} startRowIndex - start row index
 * @param {number} startColIndex - start col index
 * @param {number} rowspan - rowspan property of merger cell
 * @param {number} colspan - colspan property of merger cell
 * @private
 */

function _updateMergedCells(tableData, startRowIndex, startColIndex, rowspan, colspan) {
  var limitRowIndex = startRowIndex + rowspan;
  var limitColIndex = startColIndex + colspan;
  var colRange = range_default()(startColIndex, limitColIndex);
  range_default()(startRowIndex, limitRowIndex).forEach(function (rowIndex) {
    var rowData = tableData[rowIndex];
    var startIndex = rowIndex === startRowIndex ? 1 : 0;
    colRange.slice(startIndex).forEach(function (colIndex) {
      rowData[colIndex] = tableDataHandler.createBasicCell(rowIndex, colIndex, rowData[colIndex].nodeName);
    });
  });
}
/**
 * Unmerge selected cells.
 * @param {Array.<Array.<object>>} tableData - table data
 * @param {{rowIndex: number, colIndex: number}} startRange - start table selection range
 * @param {{rowIndex: number, colIndex: number}} endRange - end table selection range
 * @private
 */


function _unmergeCells(tableData, _ref3) {
  var startRange = _ref3.start,
      endRange = _ref3.end;
  var colRange = range_default()(startRange.colIndex, endRange.colIndex + 1);
  range_default()(startRange.rowIndex, endRange.rowIndex + 1).forEach(function (rowIndex) {
    colRange.forEach(function (colIndex) {
      var cellData = tableData[rowIndex][colIndex];
      var colspan = cellData.colspan,
          rowspan = cellData.rowspan;

      if (colspan > 1 || rowspan > 1) {
        cellData.colspan = 1;
        cellData.rowspan = 1;

        _updateMergedCells(tableData, rowIndex, colIndex, rowspan, colspan);
      }
    });
  });
}
/**
 * Find focus cell element like td or th.
 * @param {HTMLElement} newTable - changed table element
 * @param {number} rowIndex - row index of table data
 * @param {number} colIndex - column index of tabld data
 * @returns {HTMLElement}
 * @private
 */

function unmergeCell_findFocusCell(newTable, rowIndex, colIndex) {
  var tableData = tableDataHandler.createTableData(newTable);
  var cellElementIndex = tableDataHandler.findElementIndex(tableData, rowIndex, colIndex);
  var foundTr = newTable.querySelectorAll('tr')[cellElementIndex.rowIndex];
  return foundTr.querySelectorAll('td, th')[cellElementIndex.colIndex];
}
/**
 * Get command instance
 * @param {Editor} editor - editor instance
 * @returns {command} command to unmerge cell
 */


function getUnmergeCellCommand(editor) {
  var CommandManager = Object.getPrototypeOf(editor).constructor.CommandManager;
  return CommandManager.command('wysiwyg',
  /** @lends UnmergeCell */
  {
    name: 'UnmergeCells',

    /**
     * Command handler.
     * @param {WysiwygEditor} wwe - wysiwygEditor instance
     */
    exec: function exec(wwe) {
      var sq = wwe.getEditor();
      var selectionRange = sq.getSelection().cloneRange();
      wwe.focus();

      if (!sq.hasFormat('TABLE')) {
        return;
      }

      var startContainer = selectionRange.startContainer;
      var startElement = startContainer.nodeType !== 1 ? startContainer.parentNode : startContainer;
      var table = closest_default()(startElement, 'table');
      var tableData = tableDataHandler.createTableData(table);
      var selectedCells = wwe.componentManager.getManager('tableSelection').getSelectedCells();
      var tableRange = tableRangeHandler.getTableSelectionRange(tableData, selectedCells, startContainer);

      if (!_hasMergedCell(tableData, tableRange)) {
        return;
      }

      _unmergeCells(tableData, tableRange);

      var newTable = tableRenderer.replaceTable(table, tableData);

      var focusCell = unmergeCell_findFocusCell(newTable, tableRange.start.rowIndex, tableRange.start.colIndex);

      tableRenderer.focusToCell(sq, selectionRange, focusCell);
    }
  });
}
// EXTERNAL MODULE: ./node_modules/tui-code-snippet/domUtil/css.js
var css = __webpack_require__(14);
var css_default = /*#__PURE__*/__webpack_require__.n(css);

// EXTERNAL MODULE: ./node_modules/tui-code-snippet/domUtil/matches.js
var matches = __webpack_require__(12);
var matches_default = /*#__PURE__*/__webpack_require__.n(matches);

// CONCATENATED MODULE: ./src/js/mergedTableUI.js
/**
 * @fileoverview Implements table extension ui
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Change contextmenu content.
 * @param {object} popupTableUtils - PopupTableUtils instance for managing contextmenu of table
 * @param  {I18n} i18n - instance of language module
 * @private
 */

function _changeContent(popupTableUtils, i18n) {
  var POPUP_CONTENT = ["<button type=\"button\" class=\"te-table-add-row\">" + i18n.get('Add row') + "</button>", "<button type=\"button\" class=\"te-table-add-col\">" + i18n.get('Add col') + "</button>", "<button type=\"button\" class=\"te-table-remove-row\">" + i18n.get('Remove row') + "</button>", "<button type=\"button\" class=\"te-table-remove-col\">" + i18n.get('Remove col') + "</button>", '<hr/>', "<button type=\"button\" class=\"te-table-merge\">" + i18n.get('Merge cells') + "</button>", "<button type=\"button\" class=\"te-table-unmerge\">" + i18n.get('Unmerge cells') + "</button>", '<hr/>', "<button type=\"button\" class=\"te-table-col-align-left\">" + i18n.get('Align left') + "</button>", "<button type=\"button\" class=\"te-table-col-align-center\">" + i18n.get('Align center') + "</button>", "<button type=\"button\" class=\"te-table-col-align-right\">" + i18n.get('Align right') + "</button>", '<hr/>', "<button type=\"button\" class=\"te-table-remove\">" + i18n.get('Remove table') + "</button>"].join('');
  popupTableUtils.setContent(POPUP_CONTENT);

  popupTableUtils._initDOMEvent();
}

function show(element) {
  css_default()(element, {
    display: 'block'
  });
}

function hide(element) {
  css_default()(element, {
    display: 'none'
  });
}
/**
 * Bind events for merge feature of contextmenu.
 * @param {object} popupTableUtils - PopupTableUtils instance for managing contextmenu of table
 * @param {object} eventManager - event manager instance of editor
 * @param {object} selectionManager - table selection manager instance
 * @private
 */


function _bindEvents(popupTableUtils, eventManager, selectionManager) {
  var body = popupTableUtils.body;

  var _body$querySelectorAl = body.querySelectorAll('button'),
      mergeBtn = _body$querySelectorAl[4],
      unmergeBtn = _body$querySelectorAl[5];

  var separator = body.querySelector('hr');
  popupTableUtils.on('click .te-table-merge', function () {
    eventManager.emit('command', 'MergeCells');
  });
  popupTableUtils.on('click .te-table-unmerge', function () {
    eventManager.emit('command', 'UnmergeCells');
  });
  eventManager.listen('openPopupTableUtils', function () {
    var selectedCells = selectionManager.getSelectedCells();
    var selectedCellCount = selectedCells.length;

    if (selectedCellCount) {
      if (selectedCellCount < 2 || selectionManager.hasSelectedBothThAndTd(selectedCells)) {
        hide(mergeBtn);
      } else {
        show(mergeBtn);
      }

      var mergedCells = toArray_default()(selectedCells).filter(function (selectedCell) {
        return matches_default()(selectedCell, '[rowspan], [colspan');
      });

      if (mergedCells.length) {
        show(unmergeBtn);
      } else {
        hide(unmergeBtn);
      }

      show(separator);
    } else {
      hide(mergeBtn);
      hide(unmergeBtn);
      hide(separator);
    }
  });
}
/**
 * Update contextmenu UI.
 * @param {object} popupTableUtils - PopupTableUtils instance for managing contextmenu of table
 * @param {object} eventManager - event manager instance of editor
 * @param {object} selectionManager - table selection manager instance
 * @param {Editor} editor - editor instance
 */


function updateContextMenu(popupTableUtils, eventManager, selectionManager, editor) {
  var i18n = editor.i18n;

  _changeContent(popupTableUtils, i18n);

  _bindEvents(popupTableUtils, eventManager, selectionManager);
}
// CONCATENATED MODULE: ./src/js/index.js
/**
 * @fileoverview Implements table plugin
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */
















function getExtendedToMarkOptions(toMarkOptions) {
  var extendedOptions = toMarkOptions || {};
  var baseRenderer = extendedOptions.renderer;
  extendedOptions.renderer = createToMarkRenderer(baseRenderer);
  return extendedOptions;
}
/**
 * Add commands.
 * @param {object} editor - editor instance
 * @private
 */


function _addCommands(editor) {
  var wwMergeCell = getMergeCellCommand(editor);
  var wwUnergeCell = getUnmergeCellCommand(editor);
  editor.addCommand(wwMergeCell);
  editor.addCommand(wwUnergeCell);
}
/**
 * Change wysiwyg component managers
 * @param {object} wwComponentManager - componentMananger instance
 * @param {Editor} editor - editor instance
 * @private
 */


function _changeWysiwygManagers(wwComponentManager, editor) {
  wwComponentManager.removeManager('table');
  wwComponentManager.removeManager('tableSelection');
  var WwMergedTableManager = getWwMergedTableManager(editor);
  var WwMergedTableSelectionManager = getWwMergedTableSelectionManager(editor);
  wwComponentManager.addManager(WwMergedTableManager);
  wwComponentManager.addManager(WwMergedTableSelectionManager);
}
/**
 * Change html by onChangeTable function.
 * @param {string} html - original html
 * @param {function} onChangeTable - function for changing html
 * @returns {string}
 * @private
 */


function _changeHtml(html, onChangeTable) {
  var tempDiv = document.createElement('div');
  tempDiv.innerHTML = html;
  var tables = tempDiv.querySelectorAll('table');

  if (tables.length) {
    toArray_default()(tables).forEach(function (tableElement) {
      var changedTableElement = onChangeTable(tableElement);

      if (changedTableElement !== tableElement) {
        if (tableElement.hasAttribute('data-tomark-pass')) {
          changedTableElement.setAttribute('data-tomark-pass', '');
        }

        if (tableElement.hasAttribute('data-nodeid')) {
          changedTableElement.setAttribute('data-nodeid', tableElement.getAttribute('data-nodeid'));
        }

        var parentNode = tableElement.parentNode;
        parentNode.insertBefore(changedTableElement, tableElement);
        parentNode.removeChild(tableElement);
      }
    });
    html = tempDiv.innerHTML;
  }

  return html;
}
/**
 * Snatch wysiwyg command.
 * @param {{command: object}} commandWrapper - wysiwyg command wrapper
 * @param {Object.<string, Object>} commandMap - map of command names and command instances
 * @private
 */


function _snatchWysiwygCommand(commandWrapper, commandMap) {
  var command = commandWrapper.command;

  if (!command.isWWType()) {
    return;
  }

  var commandName = command.getName();

  if (commandMap[commandName]) {
    commandWrapper.command = commandMap[commandName];
  }
}
/**
 * Bind events.
 * @param {object} eventManager - eventManager instance
 * @param {Object.<string, Object>} commandMap - map of command names and command instances
 * @private
 */


function js_bindEvents(eventManager, commandMap) {
  eventManager.listen('convertorAfterMarkdownToHtmlConverted', function (html) {
    return _changeHtml(html, createMergedTable);
  });
  eventManager.listen('convertorBeforeHtmlToMarkdownConverted', function (html) {
    return _changeHtml(html, prepareTableUnmerge);
  });

  if (commandMap) {
    eventManager.listen('addCommandBefore', function (commandWrapper) {
      _snatchWysiwygCommand(commandWrapper, commandMap);
    });
  }
}
/**
 * Table merged cell plugin
 * @param {Editor|Viewer} editor - instance of Editor or Viewer
 */


function tableMergedCellPlugin(editor) {
  var eventManager = editor.eventManager;
  var isViewer = editor.isViewer();
  var commandMap = isViewer ? null : {
    AddRow: getWwAddRowCommand(editor),
    AddCol: getWwAddColumnCommand(editor),
    RemoveRow: getWwRemoveRowCommand(editor),
    RemoveCol: getWwRemoveColumnCommand(editor),
    AlignCol: getWwAlignColumnCommand(editor)
  };

  js_bindEvents(eventManager, commandMap);

  if (isViewer) {
    return;
  }

  addLangs(editor);
  var wwComponentManager = editor.wwEditor.componentManager;
  var popupTableUtils = editor.getUI().getPopupTableUtils();

  _addCommands(editor);

  _changeWysiwygManagers(wwComponentManager, editor);

  editor.toMarkOptions = getExtendedToMarkOptions(editor.toMarkOptions);

  if (popupTableUtils) {
    updateContextMenu(popupTableUtils, eventManager, wwComponentManager.getManager('tableSelection'), editor);
  }
}

/***/ })
/******/ ])["default"];